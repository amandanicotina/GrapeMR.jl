var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"N. Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbrüggen and S. J. Glaser. Optimal control of coupled spin dynamics: design of NMR pulse sequences by gradient ascent algorithms. Journal of magnetic resonance 172, 296–305 (2005).\n\n\n\n","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [GrapeMR]\nOrder   = [:function, :type]","category":"page"},{"location":"api/#GrapeMR.RF_pulse_analysis-Tuple{ControlField}","page":"API","title":"GrapeMR.RF_pulse_analysis","text":"RF_pulse_analysis(cf::ControlField; attenuation_ref = 0.0, B1_ref = 1.0, power_ref = 500.0)\n\nCalculate calibration analysis of shaped pulse\n\n### Parameters:\n- `cf::ControlField`: The control field object containing the RF waveform.\n- `attenuation_ref::Float64`: Reference attenuation in dB (default is 0.0 dB).\n- `B1_ref::Float64`: Reference RF field strength in Tesla (default is 1.0 T).\n- `power_ref::Float64`: Reference RF power in Watts (default is 500.0 W).\n\n### Returns:\nA tuple of calculated values:\n- `max_amp`: Maximum RF amplitude in Hertz (Hz).\n- `max_amp_tesla`: Maximum RF amplitude in microtesla (µT).\n- `attenuation_B1`: Attenuation in decibels (dB).\n- `power_max_B1`: Maximum power in Watts (W).\n- `power_average`: Average power in Watts (W).\n- `pulse_energy`: Pulse energy in Joules (J).\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.amplitudes_and_phases-Tuple{ControlField}","page":"API","title":"GrapeMR.amplitudes_and_phases","text":"amplitudes_and_phases(cf::ControlField)\n\nCalculates amplitudes and phases in Hz and radians\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.bSSFP_RF-Tuple{Int64, Int64, Real, Float64}","page":"API","title":"GrapeMR.bSSFP_RF","text":"bSSFP_RF(N::Int, nTR::Int, α::Real, TR::Float64)\n\nGenerates a bSSFP pulse sequence with bandwidth BW and flip angle flip_angle in radians\n\nArguments\n\nN::Int: Points\nnTR::Int: How many TRs\nα::Real: Flip angle\n`TR::Float64: Repetition time TR in seconds\n\nOutput\n\nNx1 array with bSSFP pulse amplitudes\n\nExample\n\n```julia bSSFP(gpoutput, folderpath=\"/path/to/folder\")\n\nIf no path is provided, it saves the files inside the folder where the package was installed folder name format : yyyy-mm-dd\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.bandwidth_factor-Tuple{}","page":"API","title":"GrapeMR.bandwidth_factor","text":"bandwidth_factor(cf::ControlField)\n\nExcitation frequency range\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.bloch_matrix-NTuple{5, Float64}","page":"API","title":"GrapeMR.bloch_matrix","text":"bloch_matrix(B1x::Float64, B1y::Float64, Bz::Float64, Γ1::Float64, Γ2::Float64)\n\nbloch_matrix     # Input       B1x: (::Float64) - B1x step     B1y: (::Float64) - B1x step     Bz:  (::Float64) - B1x step     Γ1:  (::Float64) - B1x step     Γ2:  (::Float64) - B1x step\n\n# Output\n- Calculated 4x4 Bloch matrix\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.bohb_hyperopt-Tuple{Vector{<:Spins}, GrapeParams, LinRange, Int64}","page":"API","title":"GrapeMR.bohb_hyperopt","text":"hyperoptimization(spins::Vector{<:Spins}, \n                  gp::GrapeParams, \n                  Tc::LinRange, \n                  max_iter::Int; \n                  i::Int=5, \n                  poly_start::Vector{Float64}=[1e-1, 1e-2], \n                  poly_degree::Vector{Int}=[1, 2, 3], \n                  B1ref::Float64=1.0)\n\nPerforms hyperparameter optimization using Bayesian Optimization and Hyperband (BOHB) for selecting hyperparameters.\n\n### Input\n- `spins::Vector{<:Spins}`: A vector containing spin systems for the optimization process.\n- `gp::GrapeParams`: Grape algorithm parameters, which include time points, cost function, and mask for which fields are being optimized.\n- `Tc::LinRange`: Range for the time control points for spline interpolation.\n- `max_iter::Int`: Maximum number of iterations for the optimizer.\n- `i::Int=5`: Number of optimization evaluations.\n- `poly_start::Vector{Float64}=[1e-1, 1e-2]`: Starting points for the polynomial learning rate.\n- `poly_degree::Vector{Int}=[1, 2, 3]`: Degrees for the polynomial learning rate.\n- `B1ref::Float64=1.0`: Reference B1 field amplitude for the RF pulse.\n\n### Output\n- An optimized object from the BOHB optimization process, containing results and optimization history.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.bruker_normalized_amplitudes_and_phases-Tuple{ControlField}","page":"API","title":"GrapeMR.bruker_normalized_amplitudes_and_phases","text":"bruker_normalized_amplitudes_and_phases(cf::ControlField)\n\nCalculates amplitudes and phases normalized to 100 and 180 deg for Bruker implementation on TopSpin. All negative phase values are added a 360deg phase\n\n### Parameters:\n- `cf::ControlField`: The control field object containing the RF waveform.\n\n### Returns:\nA tuple of normalized amplitudes and phases:\n- `norm_amp`: Maximum RF amplitude in Hertz (Hz).\n- `norm_phase`: Normalize phases in degrees.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.calculate_cost_gradient-Tuple{Symbolics.Num, Dict, Vector{Symbolics.Num}}","page":"API","title":"GrapeMR.calculate_cost_gradient","text":"calculate_cost_gradient(cost_func::Num, dict::Dict, vars::Vector{Num})\n\nGeneric function that maps variables into the gradient calculation using the Symbolics package     dM = Differential(vars[])     dCostM = expandderivatives(dM(costfunc))     P = Symbolics.unwrap(substitute.(dCostM, (dict,))[1])\n\nInput\n\n- 'cost_func::Num': Cost Function from pre-defined dictionary\n- 'dict::Dict': Variable dictionary\n- 'vars::Vector{Num}': Function variables, Mx, My, etc.\n\nOutput\n\n- 'cost_gradient::Vector{Float64}':\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.complex_signal-Tuple{ControlField}","page":"API","title":"GrapeMR.complex_signal","text":"complex_signal(cf::ControlField)\n\nCalculates complex RF signal in Hz\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.cost_function-Tuple{Isochromat, Symbol}","page":"API","title":"GrapeMR.cost_function","text":" cost_function(iso::Isochromat, cf::Symbol)\n\nFunction that gets called cost function form the cost function dictionary\n\nInput\n\n- 'iso::Isochromat': IRespective isochromat for the calculation\n- 'cf::Symbol': Cost Function\n\nOutput\n\n- '(cost_val, cost_gradient)::Tuple{Float64, Vector{Float64}}': Tuple with cost funciton value and 4x1 gradient.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.cost_offsets-Tuple{ControlField, Spin, Vector{Float64}, Symbol}","page":"API","title":"GrapeMR.cost_offsets","text":"cost_offsets(control_field::ControlField, spin_system::Spin, offsets::Vector{Float64})\n\nCalculates the cost values for a given control field (control_field) and spin system (spin_system) over a range of B0 inhomogeneities (offsets).\n\n# Arguments\n- `control_field::ControlField`: The control field object that contains the RF pulse sequence.\n- `spin_system::Spin`: The spin system for which the cost function is to be calculated.\n- `offsets::Vector{Float64}`: A vector of offset frequencies (in Hz) representing B0 inhomogeneities.\n\n# Returns\n- `cost_values::Vector{Float64}`: A vector containing the cost values corresponding to each offset in `B0_values`.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.countour_cost-Tuple{Matrix{Float64}}","page":"API","title":"GrapeMR.countour_cost","text":"countour_cost(cost_matrix::Matrix{Float64})\n\nCreates a contour plot of the cost function values over the range of B0 and B1 inhomogeneities.\n\n# Arguments\n- `cost_matrix::Matrix{Float64}`: A 2D matrix representing the cost values for combinations of B0 and B1 inhomogeneities.\n\n# Returns\n- `c::Plot`: A contour plot of the cost function map.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.create_cost_matrix-Tuple{ControlField, Spin, Vector{Float64}, Vector{Float64}, Symbol}","page":"API","title":"GrapeMR.create_cost_matrix","text":"create_cost_matrix(control_field::ControlField, spin_system::Spin, offsets::Vector{Float64}, b1_inhomogeneities::Vector{Float64})\n\nGenerates a cost matrix representing the cost function values across a range of B0 and B1 inhomogeneities.\n\n# Arguments\n- `control_field::ControlField`: The control field object that contains the RF pulse sequence\n- `spin_system::Spin`: The spin system for which the cost function is to be calculated.\n- `offsets::Vector{Float64}`: A vector of offset frequencies (in Hz) representing B0 inhomogeneities.\n- `b1_inhomogeneities::Vector{Float64}`: A vector representing B1 inhomogeneity percentages.\n\n# Returns\n- `cost_matrix::Matrix{Float64}`: A 2D matrix where each element represents the cost value for a particular \n                                    combination of B0 and B1 values. The matrix is normalized by its maximum value.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.create_folder-Tuple{String}","page":"API","title":"GrapeMR.create_folder","text":"create_folder(path::String)\n\nCreates a folder at the specified path if it doesn't already exist.\n\nArguments\n\npath::String: The path where the folder will be created.\n\nOutput\n\nReturns the path to the created folder. If the folder already exists, it simply returns the path.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.dynamics-Tuple{ControlField, Spin}","page":"API","title":"GrapeMR.dynamics","text":"dynamics(cf::ControlField, spins::Spin)\n\nFunction that returns the Isochromat object with the already calculated dynamics.\n\n# Input  \n- cf::ControlField - Adjoint State\n- spins::Spin\n\n# Output\n- iso::Isochromat\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.forward_propagation-Tuple{ControlField, Spins}","page":"API","title":"GrapeMR.forward_propagation","text":"forward_propagation     # Input       - cf: (::ControlField) - Control fields struct     - s:  (::Spins) - Spin struct\n\n# Output\n- Magnetization vector 4xN\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.get_cost_and_gradient-Tuple{Isochromat, Symbolics.Num, Vector{Symbolics.Num}}","page":"API","title":"GrapeMR.get_cost_and_gradient","text":"get_cost_and_gradient(iso::Isochromat, cost_expr::Num, vars::Vector{Num})\n\nGeneric function that maps variables into the gradient calculation using the Symbolics package     dM = Differential(vars[1])     dCostM = expandderivatives(dM(costfunc))     P = Symbolics.unwrap(substitute.(dCostM, (dict,))[1])\n\nInput\n\n- 'iso::Isochromat': Isochromts\n- 'cost_expr::Num': Cost Function\n- 'vars::Vector{Num}': Function variables -> Mx, My, etc.\n\nOutput\n\n- 'cost_func_val::Float64': Cost Function Value\n- 'cost_gradient::Vector{Float64}':\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.gradient-Tuple{Matrix{Float64}, Matrix{Float64}, Matrix{Int64}}","page":"API","title":"GrapeMR.gradient","text":"gradient(χ::Matrix{Float64}, M::Matrix{Float64}, H::Matrix)\n\ngradient     # Input       - χ = (::Matrix{Float64}) - Adjoint State     - M = (::Matrix{Float64}) - Forward Propagation     - H = (::Matrix) - Hamiltonian\n\n# Output\n- ΔJ - 1xN matrix\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.grape-Tuple{Parameters, ControlField, Vector{<:Spins}}","page":"API","title":"GrapeMR.grape","text":"grape(p::Parameters, cf::ControlField, spins::Vector{<:Spins})\n\nImplements the grape algorithm [1] \n\n### Input\n- `op::OptimizationParams`: Parameters for the optimization itself: max iterations, \n- `gp::GrapeParams`: Parameters related to Grape itself: time points, cost function, mask for which fields are being optimized.\n- `cf::ControlField`: Initial control field - spline function -\n- `spins::Vector{<:Spins}`: Vector with all spins included in the optimization\n\n### Output\nA scruct cointaing all optimization results:\n- `grape_output::GrapeOutput': Data type with the optimized control fields, spin information and spin dynamics.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.hard_RF-Tuple{Any, Any, Any}","page":"API","title":"GrapeMR.hard_RF","text":"hard_RF(N::Int, t_c::Float64)\n\nGenerates a cubic spline pulse \n\nArguments\n\nN::Int: Points\nt_c::Float64: Shaped pulse time in seconds\n\nOutput\n\n1xN array with spline pulse amplitudes\n\nExample\n\n```julia bSSFP(gpoutput, folderpath=\"/path/to/folder\")\n\nIf no path is provided, it saves the files inside the folder where the package was installed folder name format : yyyy-mm-dd\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.heatmap_cost-Tuple{Matrix{Float64}, Vector{Float64}, Vector{Float64}}","page":"API","title":"GrapeMR.heatmap_cost","text":"heatmap_cost(cost_matrix::Matrix{Float64}, offsets::Vector{Float64}, b1_inhomogeneities::Vector{Float64})\n\nGenerates a heatmap plot of the cost function values over a range of B0 and B1 inhomogeneities.\n\n# Arguments\n- `cost_matrix::Matrix{Float64}`: A 2D matrix representing the cost values for combinations of B0 and B1 inhomogeneities.\n- `offsets::Vector{Float64}`: A vector of offset frequencies (in Hz) used to label the x-axis.\n- `b1_inhomogeneities::Vector{Float64}`: A vector representing B1 inhomogeneity percentages used to label the y-axis.\n\n# Returns\n- `h::Plot`: A heatmap plot showing the cost function map with a color bar indicating cost values.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.integral_factor-Tuple{ControlField}","page":"API","title":"GrapeMR.integral_factor","text":"integral_factor(cf::ControlField)\n\nPower or energy of the RF pulse integrated over its duration\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.max_peak_amp-Tuple{Vector{ComplexF64}}","page":"API","title":"GrapeMR.max_peak_amp","text":"max_peak_amp(B1::Vector{ComplexF64})\n\nReturns the maximum RF amplitude in Hz\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.max_peak_amp_tesla-Tuple{Vector{ComplexF64}}","page":"API","title":"GrapeMR.max_peak_amp_tesla","text":"max_peak_amp_tesla(B1::Vector{ComplexF64})\n\nReturns the maximum RF amplitude in Tesla\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.plot_control_fields-Tuple{ControlField}","page":"API","title":"GrapeMR.plot_control_fields","text":"plot_control_fields(cf::ControlField; unit::String = \"Hz\")\n\nPlot the control fields of an RF pulse in different units.\n\n### Parameters:\n- `cf::ControlField`: The control field object containing the RF waveform data (`B1x`, `B1y` components).\n- `unit::String`: The unit for the plot. Supported units are:\n    - `\"Hz\"`: Plots `B1x` and `B1y` in Hertz.\n    - `\"rad/s\"`: Converts the control fields to rads/sec and plots the amplitude and phase.\n    - `\"Tesla\"`: Converts the control fields to Tesla using the gyromagnetic ratio for ¹H and plots in microtesla (µT).\n\n### Returns:\n- A plot object displaying the control fields in the specified units with amplitude and phase information.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.plot_cost_offset-Tuple{Vector{Float64}, Vector{Float64}}","page":"API","title":"GrapeMR.plot_cost_offset","text":"plot_cost_offset(cost_profile::Vector{Float64}, B0_values::Vector{Float64})\n\nCreates a plot of the cost values as a function of B0 offset frequencies.\n\n# Arguments\n- `cost_profile::Vector{Float64}`: A vector containing the cost values to be plotted.\n- `B0_values::Vector{Float64}`: A vector of offset frequencies (in Hz) corresponding to the cost values.\n\n# Returns\n- `p::Plot`: A plot object displaying the cost function offset profile.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.plot_cost_values-Tuple{Vector{Float64}, GrapeParams}","page":"API","title":"GrapeMR.plot_cost_values","text":"plot_cost_values(cost::Vector{Float64}, gp::GrapeParams)\n\nPlot the cost function convergence over iterations during the GRAPE optimization process.\n\n### Parameters:\n- `cost::Vector{Float64}`: A vector containing the cost values at each iteration.\n- `gp::GrapeParams`: The parameters of the GRAPE optimization, including the cost function name.\n\n### Returns:\n- A plot object displaying the convergence of the cost function over the iterations.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.plot_magnetization_control_field-Tuple{ControlField, Vector{Isochromat}}","page":"API","title":"GrapeMR.plot_magnetization_control_field","text":"plot_magnetization_control_field(cf::ControlField, isos::Vector{Isochromat})\n\nPlot the magnetization trajectory for a set of isochromats and the corresponding control field.\n\n### Parameters:\n- `cf::ControlField`: The control field object containing the RF waveform data (`B1x`, `B1y` components).\n- `isos::Vector{Isochromat}`: A vector of isochromat objects representing different spin systems.\n\n### Returns:\n- A plot object displaying:\n    1. The magnetization trajectory in the transverse plane.\n    2. The control field amplitude and phase over time.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.plot_transverse_magnetization-Tuple{Vector{Isochromat}}","page":"API","title":"GrapeMR.plot_transverse_magnetization","text":"2D Magnetization Plots\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.random_sampler-Tuple{Vector{<:Spins}, GrapeParams, LinRange, StepRange}","page":"API","title":"GrapeMR.random_sampler","text":"random_sampler(spins::Vector{<:Spins}, \n              gp::GrapeParams, \n              Tc::LinRange, \n              max_iter::StepRange; \n              i::Int=50, \n              poly_start::Vector{Float64}=[1e-1, 1e-2], \n              poly_degree::Vector{Int}=[1, 2, 3], \n              B1ref::Float64=1.0)\n\nPerforms random sampling for hyperparameter optimization.\n\n### Input\n- `spins::Vector{<:Spins}`: A vector containing spin systems for the optimization process.\n- `gp::GrapeParams`: Grape algorithm parameters, which include time points, cost function, and mask for which fields are being optimized.\n- `Tc::LinRange`: Range for the time control points for spline interpolation.\n- `max_iter::StepRange`: Range for the maximum number of iterations for the optimizer.\n- `i::Int=50`: Number of random samples to evaluate.\n- `poly_start::Vector{Float64}=[1e-1, 1e-2]`: Starting points for the polynomial learning rate.\n- `poly_degree::Vector{Int}=[1, 2, 3]`: Degrees for the polynomial learning rate.\n- `B1ref::Float64=1.0`: Reference B1 field amplitude for the RF pulse.\n\n### Output\n- A random hyperparameter optimization object using random sampling.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.run_cost_analysis-Tuple{ControlField, Spins, Float64, Int64, Symbol}","page":"API","title":"GrapeMR.run_cost_analysis","text":"run_cost_analysis(grape_output::GrapeOutput, offset::Float64, b1_inhomogeneity_percent::Int)\n\nRuns a complete cost analysis for the specified GrapeOutput object over a range of B0 and B1 inhomogeneities,  and generates plots to visualize the cost function.\n\n# Arguments\n- `control_field::ControlField`: The control field object that contains the RF pulse sequence.\n- `spin_system::Spin`: The spin system for which the cost function is to be calculated.\n- `offset::Float64`: The range of offset frequencies (in Hz) for the B0 inhomogeneities.\n- `b1_inhomogeneity_percent::Int`: The percentage of B1 inhomogeneity to consider for the analysis.\n\n# Workflow\n1. Generates a range of B0 values from `-offset` to `offset`.\n2. Computes cost values for the specified B0 and B1 inhomogeneities using `cost_offsets` and `create_cost_matrix`.\n3. Plots the cost function offset profile using `plot_cost_offset`.\n4. Generates a heatmap of the cost matrix using `heatmap_cost`.\n5. Creates a contour plot of the cost matrix using `countour_cost`.\n\n# Example\nrun_cost_analysis(grape_output, 50.0, 30)\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.save_bohb_data-Tuple{Any}","page":"API","title":"GrapeMR.save_bohb_data","text":"save_bohb_data(bohb::GrapeMR.GrapeOutput; folder_path = pwd())\n\nSave data related to BOHB optimization into a folder organized by date.\n\nArguments\n\nbohb::GrapeMR.GrapeOutput: The output from a BOHB optimization process.\nfolder_path::String = pwd(): The folder path where data will be saved. Defaults to the current working directory.\n\nOutput\n\nReturns the full path to the folder where the data was saved.\n\nSaved Files\n\nbohb.jld2: Contains BOHB result in JLD2 format.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.save_grape_data-Tuple{GrapeOutput}","page":"API","title":"GrapeMR.save_grape_data","text":"save_grape_data(go::GrapeMR.GrapeOutput; folder_path = pwd())\n\nSave data related to GRAPE optimization into a folder organized by date.\n\nArguments\n\ngo::GrapeMR.GrapeOutput: The output from a GRAPE optimization process.\nfolder_path::String = pwd(): The folder path where data will be saved. Defaults to the current working directory.\n\nOutput\n\nReturns the full path to the folder where the data was saved.\n\nSaved Files\n\ngrape_output.jld2: Contains the entire GrapeOutput struct in JLD2 format.\ndict_cost_values.csv: CSV file containing the cost values from the optimization process.\ndict_control_field.csv: CSV file containing control field values (B1x, B1y, Bz, and RF time).\ndict_iso_spins.csv: CSV file containing isochromat spin parameters.\n\nIf no path is provided, it saves the files inside the folder where the package was installed folder name format : yyyy-mm-dd\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.sinc_RF-Tuple{Int64, Float64, Float64}","page":"API","title":"GrapeMR.sinc_RF","text":"sinc_RF(N::Int, t_c::Float64, BW_Hz::Real, flip_angle::Float64)\n\nGenerates a sinc pulse with bandwidth BW and flip angle flip_angle in radians\n\nArguments\n\nN::Int: Points\nt_c::Float64: Shaped pulse time in seconds\nBW_Hz::Real: Pulse bandwidth\nflip_angle::Float64: Flip angle\n\nOutput\n\n1xN array with sinc pulse amplitudes\n\nExample\n\n```julia bSSFP(gpoutput, folderpath=\"/path/to/folder\")\n\nIf no path is provided, it saves the files inside the folder where the package was installed folder name format : yyyy-mm-dd\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.spline_RF-Tuple{Any, Any, Any}","page":"API","title":"GrapeMR.spline_RF","text":"spline_RF(N::Int, t_c::Float64)\n\nGenerates a cubic spline pulse \n\nArguments\n\nN::Int: Points\nt_c::Float64: Shaped pulse time in seconds\nB1_ref::Float64: Reference, normally pulse maximum amplitude\n\nOutput\n\nControlField struct \n\nExample\n\n```julia bSSFP(gpoutput, folderpath=\"/path/to/folder\")\n\nIf no path is provided, it saves the files inside the folder where the package was installed folder name format : yyyy-mm-dd\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.steady_state-Tuple{SteadyState}","page":"API","title":"GrapeMR.steady_state","text":"steady_state(s::GrapeMR.SteadyState)\n\nCalculates the steady-state signal of a bSSFP sequence for a given set of parameters. The function calculates the magnetization evolution  using repeated RF excitations and free precession steps until the steady state is reached.\n\n# Arguments\n- `s::GrapeMR.SteadyState`: A struct containing TR (Repetition Time), TE (Echo Time), T1 (Spin-lattice relaxation time), \n                            T2 (Spin-spin relaxation time), α (Flip angle in radians), Δϕ (Phase cycling increment), \n                            M_init (Initial magnetization vector), and B0inho (B0 inhomogeneity).\n# Returns\n- `signal::Vector{ComplexF64}`: The complex steady-state signal of the spin system.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.steady_state_geometric-Tuple{SteadyState}","page":"API","title":"GrapeMR.steady_state_geometric","text":"steady_state_geometric(s::GrapeMR.SteadyState)\n\nCalculates the transverse steady-state magnetization using a geometric solution for a bSSFP sequence. Uses a geometric approach to  derive the transverse component of the steady-state magnetization.\n\n# Arguments\n- `s::GrapeMR.SteadyState`: Struct containing the sequence parameters and spin system properties.\n\n# Returns\n- `Mxy::Vector{Float64}`: The steady-state transverse magnetization magnitude `Mxy`\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.steady_state_geometric_Mz-Tuple{SteadyState}","page":"API","title":"GrapeMR.steady_state_geometric_Mz","text":"steady_state_geometric_Mz(s::GrapeMR.SteadyState)\n\nCalculates the longitudinal steady-state magnetization using a geometric solution for a bSSFP sequence. Uses a geometric approach to  derive the longitudinal component of the steady-state magnetization.\n\n# Arguments\n- `s::GrapeMR.SteadyState`: Struct containing the sequence parameters and spin system properties.\n\n# Returns\n- `Mz::Vector{Float64}`: The steady-state longitudinal magnetization magnitude `Mz`\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.update!-Tuple{ControlField, Tuple{Matrix{Float64}, Matrix{Float64}}, Float64}","page":"API","title":"GrapeMR.update!","text":"update(cf::ControlField, ∇xy::Tuple, ϵ::Float64)\n\nupdate     # Input       - cf:  (::ControlField) - Control fields struct     - ∇xy: (::Tuple) - Calculated gradients for x and y components     - ϵ:   (::Float64) - Weigth of gradient\n\n# Output\n- Control Field - 1xN matrix\n\n\n\n\n\n","category":"method"},{"location":"#GrapeMR.jl","page":"Introduction","title":"GrapeMR.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Documentation for GrapeMR.jl","category":"page"},{"location":"#Magnetic-systems","page":"Introduction","title":"Magnetic systems","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Given a homogeneus magnetic field vecB_0 = B_0textbfz \nMagnetic moments align with vecB_0 resulting in a bulk magnetization M_0 along the z-axis.\nThe presence of vecB_0 gives raise (?) to a resonance condition specific for each atomic nuclei.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"omega_0 = -gamma B_0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where omega_0 [rads/s] is the Larmor frequency, gamma [rads/s/T]  the gyromagnetic ratio and B_0 [T] the homogenios magnetic field. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"An inhomogeneous magnetic field B_1(t), perpendicular to B_0, when irradiated in the resonance frequency, rotates the magnetization. The rotation angle is described as, ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"alpha = 2 pi gamma B_1 Delta t","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where Delta t is the duration of the B_1(t) field. Because the gyromagnetic ratio of the proton is O(MHz), so is the B_1(t), hence, radio frequency field. It can be rewritten as a combination of its x-y components, B_1(t) = B_1x + i B_1y. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Once B_1(t) is turned off, the system starts to relax back to equilibrium, generating a signal called FID (Free Induction Decay).\nThe relaxation parameters, T_1 and T_2, are individual to each molecule, therefore, generating different decays for different molecules excited by the same RF pulse.\nFrom the signal detected, one can calculate the magnetization values.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<!– ","category":"page"},{"location":"#Optimal-Control","page":"Introduction","title":"Optimal Control","text":"","category":"section"},{"location":"#Description-of-System-Dynamics","page":"Introduction","title":"Description of System Dynamics","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The dynamics of a system can be mathematically described by the following system of equations:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"begincases\n    dotvecx(t) = vecf(x(t)) \n    x(0) = x_0 (t  0)\nendcases","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Here, vecf represents all of the forces acting on the system. In a control dynamics, a function u(t), called the control function, is introduced to allow for manipulation of the system. The system dynamics can now be written as:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"begincases\n    dotvecx(t) = vecf(x(t) u(t)) \n    x(0) = x_0 (t  0) \nendcases","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The goal in this type of system is to find the \"best set\" of controls. To achieve this, a reward function C is introduced. If u^*(t) is the optimal control, then for all u(t), the reward function satisfies:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"C(u^*)  C(u)","category":"page"},{"location":"#Optimal-Control-in-NMR","page":"Introduction","title":"Optimal Control in NMR","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"In Nuclear Magnetic Resonance (NMR), a controled dynamics can be achieved by designing the RF pulses as the controls. Hence, the magnetization dynamics would be proportional to,","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"dotM(t) = f(M_0 T_1 T_2 B_1(t) M(t))","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"More specifically, the dynamics are governed by the Bloch Equations, which can be expressed as follows:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"beginbmatrix\n    dotM_x  dotM_y  dotM_z\nendbmatrix = \nbeginbmatrix\n    -1T_2  Delta B_0  -B1_y \n    -Delta B_0  -1T_2  B1_x \n    B1_y  -B1_x  1T_1\nendbmatrix\nbeginbmatrix\n    M_x  M_y  M_z\nendbmatrix + \nbeginbmatrix\n    0  0  M_0T_1\nendbmatrix","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where the dynamics of the magnetization is described by the vector vecM = (M_x M_y M_z). ","category":"page"},{"location":"#Cost-Function","page":"Introduction","title":"Cost Function","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Defining a cost function is essencial in this processes since it is based on it that the system will be optimized. In the case of contrast saturation, given two samples a and b, the goal is to supress one signal while maximizing the other. This can be achieved using the following cost function:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"C^(ab) = vecM^(b)(t_f) - (M_z^(a)(t_f))^2","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This cost function yields the best value of -1 when the signal of sample a is zero and the signal of sample b is maximum.","category":"page"},{"location":"#GRAPE-Algorithm","page":"Introduction","title":"GRAPE Algorithm","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The basic algorithm for optimization is Gradient Ascent, which can be described using the following steps:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Choose an initial control field (can be an arbitrary smart guess);\nCompute the cost function C(u);\nCompute the gradient fracdelta Cdelta u;\nUpdate the current control field using the formula: vecomega^(n + 1) = vecomega^(n) - gamma fracdelta Cdelta u;\nRepeat 2-4 until convergence.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"While this is the simplest way to apply the gradient ascent algorithm, a more precise approach involves using forward and backward propagation to update the control field. This approach will be discussed in the following section.  –>","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"tutorial.jl\"","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The goal is to show how to implement the GrapeMR.jl package","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Define your physical system: Spins, relaxation values, inhomogeneities, etc.\nOptimization parameters: Scheduler parameters, max iterations, etc.\nGrape Parameters: Time steps, cost function and which fields to optimize.\nGenerate initial control field: Spline","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using GrapeMR","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Physical system: Initial magnetization state, relaxation values in seconds, label are the spins names, target: cost function dependent, B0 inhomonegenty in Herz. At the end, create the spin object with all spins","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"M0 = [0.0, 0.0, 1.0]\nT1 = [1.3, 0.73]\nT2 = [2.0, 0.04]\nlabel  = [\"T1=$(T1[1]*1e3)ms\", \"T1=$(T1[2]*1e3)ms\"]\ntarget = [\"min\", \"max\"]\nB0 = 30.0\noffset = collect(-B0/2:5:B0/2)\nΔB1 = [1.0]\nspins = Spin(M0, T1, T2, offset, ΔB1, target, label)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Optimization Parameters:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Tc, poly_start, poly_degree, max_iter = 0.836, 0.1, 1, 1#2000 #  bohb.minimizer # 0\nopt_params   = OptimizationParams(poly_start, poly_degree,  Int(ceil(max_iter)))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Grape Parameters","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"grape_params = GrapeParams(1500, :saturation_contrast_Mx, [true true false])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"RF","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"N = 1500\nB1ref = 1.0\ncontrol_field = spline_RF(N, Tc, B1ref)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Run Optimization","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"params = Parameters(grape_params, opt_params)\ngrape_output = grape(params, control_field, spins);\nnothing #hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Plots","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plot_magnetization_control_field(grape_output.control_field, grape_output.isochromats);\n\n# The Spin struct","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"''' julia struct Spin <: Spins   M_init::Vector{Float64}   T1::Float64   T2::Float64   #δ::Vector{Float64}   B0inho::Float64   B1inho::Float64   target::String   label::String   Nspins::Float64 end '''","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"}]
}
