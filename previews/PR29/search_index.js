var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [GrapeMR]\nOrder   = [:function, :type]","category":"page"},{"location":"api/#GrapeMR.RF_pulse_analysis-Tuple{ControlField}","page":"API","title":"GrapeMR.RF_pulse_analysis","text":"RF_pulse_analysis(cf::ControlField; attenuation_ref = 0.0, B1_ref = 1.0, power_ref = 500.0)\n\nCalculate calibration analysis of shaped pulse\n\nArguments\n\ncf::ControlField: The control field object containing the RF waveform.\nattenuation_ref::Float64: Reference attenuation in dB (default is 0.0 dB).\nB1_ref::Float64: Reference RF field strength in Tesla (default is 1.0 T).\npower_ref::Float64: Reference RF power in Watts (default is 500.0 W).\n\nOutputs:\n\nA tuple of calculated values:\n\nmax_amp: Maximum RF amplitude in Hertz (Hz).\nmax_amp_tesla: Maximum RF amplitude in microtesla (µT).\nattenuation_B1: Attenuation in decibels (dB).\npower_max_B1: Maximum power in Watts (W).\npower_average: Average power in Watts (W).\npulse_energy: Pulse energy in Joules (J).\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.amplitudes_and_phases-Tuple{ControlField}","page":"API","title":"GrapeMR.amplitudes_and_phases","text":"amplitudes_and_phases(cf::ControlField)\n\nCalculates amplitudes and phases in Hz and radians\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.bSSFP_RF-Tuple{Int64, Int64, Real, Float64}","page":"API","title":"GrapeMR.bSSFP_RF","text":"bSSFP_RF(N::Int, nTR::Int, α::Real, TR::Float64)\n\nGenerates an RF pulse sequence for bSSFP with specified flip angle and repetition time.\n\nArguments\n\nN::Int: Number of points per repetition.\nnTR::Int: Number of TR periods (repetitions).\nα::Real: Flip angle in radians.\nTR::Float64: Repetition time in seconds.\n\nReturns\n\nA 1D array containing the bSSFP RF pulse sequence.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.backward_propagation!-Tuple{AbstractMatrix, ControlField, Isochromat}","page":"API","title":"GrapeMR.backward_propagation!","text":"backward_propagation!(χ::AbstractMatrix, cf::ControlField, iso::Isochromat)\n\nIn-place backward propagation for the adjoint state matrix, calculating gradients for the control fields.\n\nArguments\n\nχ::AbstractMatrix: Matrix to store the adjoint state (4xN).\ncf::ControlField: Struct containing control field parameters.\niso::Isochromat: Isochromat containing the magnetization data for backward propagation.\n\nReturns\n\nχ: Updated adjoint state matrix (4xN) after backward propagation.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.backward_propagation-Tuple{AbstractVector, ControlField, Isochromat}","page":"API","title":"GrapeMR.backward_propagation","text":"backward_propagation(cost_grad::AbstractVector, cf::ControlField, iso::Isochromat)\n\nPerforms backward propagation for the adjoint state matrix, calculating gradients for the control fields.\n\nArguments\n\ncost_grad::AbstractVector: Gradient of the cost function for the initial adjoint state.\ncf::ControlField: Struct containing control field parameters.\niso::Isochromat: Isochromat containing the magnetization data for backward propagation.\n\nReturns\n\nχ::Matrix{Float64}: Adjoint state matrix (4xN) after backward propagation.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.bandwidth_factor-Tuple{}","page":"API","title":"GrapeMR.bandwidth_factor","text":"bandwidth_factor(cf::ControlField)\n\nExcitation frequency range\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.bloch_matrix-NTuple{5, Float64}","page":"API","title":"GrapeMR.bloch_matrix","text":"bloch_matrix(B1x::Float64, B1y::Float64, Bz::Float64, Γ1::Float64, Γ2::Float64)\n\nCalculates the Bloch matrix for spin dynamics.\n\nArguments\n\nB1x::Float64: x-component of the B1 field.\nB1y::Float64: y-component of the B1 field.\nBz::Float64: z-component of the magnetic field.\nΓ1::Float64: Longitudinal relaxation rate.\nΓ2::Float64: Transverse relaxation rate.\n\nReturns\n\nA 4x4 Bloch matrix based on the given field components and relaxation rates.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.bohb_hyperopt-Tuple{Vector{<:Spins}, GrapeParams, LinRange, Int64}","page":"API","title":"GrapeMR.bohb_hyperopt","text":"bohb_hyperopt(spins::Vector{<:Spins}, \n              gp::GrapeParams, \n              Tc::LinRange, \n              max_iter::Int; \n              i::Int=5, \n              poly_start::Vector{Float64} = [5e-1, 1e-1, 1e-2], \n              poly_degree::Vector{Int} = [1, 2], \n              B1ref::Float64 = 1.0)\n\nPerforms hyperparameter optimization using Bayesian Optimization and Hyperband (BOHB).\n\nArguments\n\nspins::Vector{<:Spins}: Vector of spin systems for the optimization process.\ngp::GrapeParams: GRAPE algorithm parameters, including cost function and fields to optimize.\nTc::LinRange: Range for time control points for spline interpolation.\nmax_iter::Int: Maximum number of optimization iterations.\ni::Int=5: Number of optimization evaluations.\npoly_start::Vector{Float64}: Initial values for polynomial learning rate.\npoly_degree::Vector{Int}: Degrees for the polynomial learning rate.\nB1ref::Float64=1.0: Reference B1 field amplitude.\n\nReturns\n\nA BOHB optimization object with optimized hyperparameter configurations and costs.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.bruker_normalized_amplitudes_and_phases-Tuple{ControlField}","page":"API","title":"GrapeMR.bruker_normalized_amplitudes_and_phases","text":"bruker_normalized_amplitudes_and_phases(cf::ControlField)\n\nCalculates amplitudes and phases normalized to 100 and 180 deg for Bruker implementation on TopSpin. All negative phase values are added a 360deg phase\n\nArguments\n\ncf::ControlField: The control field object containing the RF waveform.\n\nOutputs:\n\nA tuple of normalized amplitudes and phases:\n\nnorm_amp: Maximum RF amplitude in Hertz (Hz).\nnorm_phase: Normalize phases in degrees. \n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.color_palette-Tuple{Union{Int64, AbstractArray}}","page":"API","title":"GrapeMR.color_palette","text":"color_palette(var::Union{AbstractArray, Int})\n\nGenerates a color palette using the rainbow color scheme for the specified array of indices or integer count.\n\nArguments\n\nvar::Union{AbstractArray, Int}: Array or integer specifying the number of colors required.\n\nReturns\n\nA ColorScheme object with colors matching the length or count of var.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.complex_signal-Tuple{ControlField}","page":"API","title":"GrapeMR.complex_signal","text":"complex_signal(cf::ControlField)\n\nCalculates complex RF signal in Hz\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.cost_offsets-Tuple{ControlField, Spin, Vector{Float64}, Function}","page":"API","title":"GrapeMR.cost_offsets","text":"cost_offsets(control_field::ControlField, spin_system::Spin, offsets::Vector{Float64})\n\nCalculates the cost values for a given control field (control_field) and spin system (spin_system) over a range of B0 inhomogeneities (offsets).\n\nArguments\n\ncontrol_field::ControlField: The control field object that contains the RF pulse sequence.\nspin_system::Spin: The spin system for which the cost function is to be calculated.\noffsets::Vector{Float64}: A vector of offset frequencies (in Hz) representing B0 inhomogeneities.\n\nOutputs\n\ncost_values::Vector{Float64}: A vector containing the cost values corresponding to each offset in B0_values.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.countour_cost-Tuple{Matrix{Float64}, Vector{Float64}, Vector{Float64}}","page":"API","title":"GrapeMR.countour_cost","text":"countour_cost(cost_matrix::Matrix{Float64})\n\nCreates a contour plot of the cost function values over the range of B0 and B1 inhomogeneities.\n\nArguments\n\ncost_matrix::Matrix{Float64}: A 2D matrix representing the cost values for combinations of B0 and B1 inhomogeneities.\n\nOutputs\n\nc::Plot: A contour plot of the cost function map.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.create_cost_matrix-Tuple{ControlField, Spin, Vector{Float64}, Vector{Float64}, Function}","page":"API","title":"GrapeMR.create_cost_matrix","text":"create_cost_matrix(control_field::ControlField, spin_system::Spin, offsets::Vector{Float64}, b1_inhomogeneities::Vector{Float64})\n\nGenerates a cost matrix representing the cost function values across a range of B0 and B1 inhomogeneities.\n\nArguments\n\ncontrol_field::ControlField: The control field object that contains the RF pulse sequence\nspin_system::Spin: The spin system for which the cost function is to be calculated.\noffsets::Vector{Float64}: A vector of offset frequencies (in Hz) representing B0 inhomogeneities.\nb1_inhomogeneities::Vector{Float64}: A vector representing B1 inhomogeneity percentages.\n\nOutputs\n\ncost_matrix::Matrix{Float64}: A 2D matrix where each element represents the cost value for a particular                                        combination of B0 and B1 values. The matrix is normalized by its maximum value.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.create_folder-Tuple{String}","page":"API","title":"GrapeMR.create_folder","text":"create_folder(path::String)\n\nCreates a folder at the specified path if it doesn't already exist.\n\nArguments\n\npath::String: The path where the folder will be created.\n\nOutput\n\nReturns the path to the created folder. If the folder already exists, it simply returns the path.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.create_spline-Tuple{AbstractArray, AbstractArray, AbstractArray}","page":"API","title":"GrapeMR.create_spline","text":"create_spline(spline_time::AbstractArray, control_time_vals::AbstractArray, B1_random_vals::AbstractArray)\n\nCreates a cubic spline interpolation for the control field based on the specified time and amplitude values.\n\nArguments\n\nspline_time::AbstractArray: Array of time points for the spline.\ncontrol_time_vals::AbstractArray: Array of control time points for evaluation.\nB1_random_vals::AbstractArray: Array of B1 amplitude values for spline generation.\n\nReturns\n\nArray of interpolated control field values at each control time.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.dynamics-Tuple{ControlField, Spins}","page":"API","title":"GrapeMR.dynamics","text":"dynamics(cf::ControlField, spin::Spins)\n\nCalculates and returns the Isochromat object representing the spin dynamics under a given control field.\n\nArguments\n\ncf::ControlField: Control field affecting the spin dynamics.\nspin::Spin: Spin object for which dynamics are computed.\n\nReturns\n\niso::Isochromat: Isochromat containing the calculated magnetization dynamics.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.export_bruker-Tuple{GrapeOutput}","page":"API","title":"GrapeMR.export_bruker","text":"export_bruker(go::GrapeOutput; folder_path = pwd())\n\nExports the GRAPE optimization results to a Bruker-compatible .exc file format for use in TopSpin software.\n\nArguments\n\ngo::GrapeOutput: The output struct from GRAPE optimization containing control field data.\nfolder_path::String=pwd(): The directory path where the .exc file will be saved. Defaults to the current working directory.\n\nFile Structure\n\nThe generated file includes metadata such as date, time, amplitude, and phase ranges.\nAmplitude and phase data points are formatted for compatibility with Bruker TopSpin.\n\nOutputs\n\nSaves a .exc file named based on the GRAPE output and current configuration in the specified folder.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.forward_propagation!-Tuple{AbstractMatrix, ControlField, Spins}","page":"API","title":"GrapeMR.forward_propagation!","text":"forward_propagation!(M::AbstractMatrix, cf::ControlField, s::Spins)\n\nIn-place version of forward propagation that updates the provided magnetization matrix.\n\nArguments\n\nM::AbstractMatrix: Matrix to store the forward-propagated magnetization (4xN).\ncf::ControlField: Struct containing control field parameters.\ns::Spins: Spin struct with initial magnetization and relaxation parameters.\n\nReturns\n\nM: Updated magnetization matrix (4xN) with forward propagation results.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.forward_propagation-Tuple{ControlField, Spins}","page":"API","title":"GrapeMR.forward_propagation","text":"forward_propagation(cf::ControlField, s::Spins)\n\nPerforms forward propagation for the magnetization vector under the influence of control fields.\n\nArguments\n\ncf::ControlField: Struct containing control field parameters.\ns::Spins: Spin struct with initial magnetization and relaxation parameters.\n\nReturns\n\nM::Matrix{Float64}: Magnetization matrix (4xN) at each time step.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.gaussian_RF-Tuple{Int64, Float64, Float64}","page":"API","title":"GrapeMR.gaussian_RF","text":"gaussian_RF(N::Int, t_c::Float64, B1ref::Float64)\n\nGenerates a Gaussian-shaped RF pulse.\n\nArguments\n\nN::Int: Number of time points.\nt_c::Float64: Duration of the pulse in seconds.\nB1ref::Float64: Reference amplitude for scaling the pulse.\n\nReturns\n\nA ControlField struct with Gaussian-distributed B1x and B1y components.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.get_resources_configurations_hband-Tuple{Int64, Float32}","page":"API","title":"GrapeMR.get_resources_configurations_hband","text":"get_resources_configurations_hband(η::Int, R::Float32)\n\nCalculates the resources and configurations for each stage of the Hyperband algorithm.\n\nArguments\n\nη::Int: Downsampling factor, typically used in Hyperband.\nR::Float32: Maximum resource budget (e.g., number of iterations).\n\nReturns\n\nPrints the calculated resources (n) and budgets (r) for each Hyperband stage.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.get_target_properties-Tuple{Any, Any}","page":"API","title":"GrapeMR.get_target_properties","text":"get_target_properties(s, colors)\n\nDetermines the color and label for a given spin target (\"max\", \"min\", or default).\n\nArguments\n\ns::Spin: A spin object with target and label properties.\ncolors::Vector: A vector of colors from the color palette.\n\nReturns\n\nA tuple (color, label) with the color and label for the given spin target.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.gradient-Tuple{Matrix{Float64}, Matrix{Float64}, AbstractMatrix{Int64}}","page":"API","title":"GrapeMR.gradient","text":"gradient(χ::Matrix{Float64}, M::Matrix{Float64}, H::Matrix)\n\nCalculates the gradient of the cost function with respect to the Hamiltonian for each time step.\n\nArguments\n\nχ::Matrix{Float64}: Adjoint state matrix.\nM::Matrix{Float64}: Forward propagation matrix.\nH::Matrix: Hamiltonian matrix.\n\nReturns\n\ngrad::Matrix{Float64}: Gradient of the cost function, as a 1xN matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.grape-Tuple{Parameters, ControlField, Vector{<:Spins}}","page":"API","title":"GrapeMR.grape","text":"grape(p::Parameters, cf::ControlField, spins::Vector{<:Spins})\n\nExecutes the GRAPE algorithm to optimize control fields for spin dynamics in an NMR/MRI system.\n\nArguments\n\np::Parameters: Struct containing optimization parameters, including maximum iterations and cost function.\ncf::ControlField: Initial control field, typically as a spline function.\nspins::Vector{<:Spins}: Vector of spins included in the optimization process.\n\nReturns\n\ngrape_output::GrapeOutput: Struct containing optimization results, including optimized control fields, spin dynamics, and cost function values.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.hard_RF-Tuple{Any, Any, Any}","page":"API","title":"GrapeMR.hard_RF","text":"hard_RF(N::Int, t_c::Float64, B1ref::Float64)\n\nGenerates a hard RF pulse with constant amplitude in the x-axis and zero amplitude in the y-axis.\n\nArguments\n\nN::Int: Number of time points.\nt_c::Float64: Duration of the pulse in seconds.\nB1ref::Float64: Amplitude of the RF pulse.\n\nReturns\n\nA ControlField struct with constant B1x and zero B1y components.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.hband_hyperopt-Tuple{Vector{<:Spins}, GrapeParams, LinRange, Int64}","page":"API","title":"GrapeMR.hband_hyperopt","text":"hband_hyperopt(spins::Vector{<:Spins}, \n               gp::GrapeParams, \n               Tc::LinRange, \n               max_iter::Int; \n               B1ref::Float64 = 1.0)\n\nExecutes Hyperband optimization for selecting hyperparameters.\n\nArguments\n\nspins::Vector{<:Spins}: Vector of spin systems for the optimization process.\ngp::GrapeParams: GRAPE algorithm parameters, including cost function and fields to optimize.\nTc::LinRange: Range for time control points for spline interpolation.\nmax_iter::Int: Maximum number of optimization iterations.\nB1ref::Float64=1.0: Reference B1 field amplitude.\n\nReturns\n\nA Hyperband optimization object with configurations, costs, and history.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.initialize_plot-Tuple{String, String, String}","page":"API","title":"GrapeMR.initialize_plot","text":"initialize_plot(title, xlabel, ylabel; zlabel=nothing)\n\nCreates a plot object with common settings and title and axis labels.\n\nArguments\n\ntitle::String: Title of the plot.\nxlabel::String: Label for the x-axis.\nylabel::String: Label for the y-axis.\nzlabel::Union{String, Nothing}: Label for the z-axis (optional, only for 3D plots).\n\nReturns\n\np: A plot object with preconfigured labels and settings.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.integral_factor-Tuple{ControlField}","page":"API","title":"GrapeMR.integral_factor","text":"integral_factor(cf::ControlField)\n\nPower or energy of the RF pulse integrated over its duration\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.max_peak_amp-Tuple{Vector{ComplexF64}}","page":"API","title":"GrapeMR.max_peak_amp","text":"max_peak_amp(B1::Vector{ComplexF64})\n\nReturns the maximum RF amplitude in Hz\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.max_peak_amp_tesla-Tuple{Vector{ComplexF64}}","page":"API","title":"GrapeMR.max_peak_amp_tesla","text":"max_peak_amp_tesla(B1::Vector{ComplexF64})\n\nReturns the maximum RF amplitude in Tesla\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.plot_config-Tuple{}","page":"API","title":"GrapeMR.plot_config","text":"plot_config()\n\nSets up a default plot configuration for consistency in appearance across plots.\n\nReturns\n\np: A plot object with font sizes, frame style, and grid style preconfigured.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.plot_control_fields-Tuple{ControlField}","page":"API","title":"GrapeMR.plot_control_fields","text":"plot_control_fields(cf::ControlField; unit::String = \"Hz\")\n\nPlot the control fields of an RF pulse in different units.\n\nArguments\n\ncf::ControlField: The control field object containing the RF waveform data (B1x, B1y components).\nunit::String: The unit for the plot. Supported units are:\n\"Hz\": Plots B1x and B1y in Hertz.\n\"rad/s\": Converts the control fields to rads/sec and plots the amplitude and phase.\n\"Tesla\": Converts the control fields to Tesla using the gyromagnetic ratio for ¹H and plots in microtesla (µT).\n\nReturns\n\nA plot object displaying the control fields in the specified units with amplitude and phase information.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.plot_control_fields_phase_shift-Tuple{ControlField}","page":"API","title":"GrapeMR.plot_control_fields_phase_shift","text":"plot_control_fields_phase_shift(cf::ControlField; ψ::Float64 = π)\n\nPlot the control fields of an RF pulse after applying a phase shift.\n\nArguments\n\ncf::ControlField: The control field object containing the RF waveform data (B1x, B1y components).\nψ::Float64: The phase shift to apply to the control fields (default is π radians).\n\nReturns\n\nA plot object displaying the control fields with the specified phase shift.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.plot_cost_offset-Tuple{Vector{Float64}, Vector{Float64}}","page":"API","title":"GrapeMR.plot_cost_offset","text":"plot_cost_offset(cost_profile::Vector{Float64}, B0_values::Vector{Float64})\n\nCreates a plot of the cost values as a function of B0 offset frequencies.\n\nArguments\n\ncost_profile::Vector{Float64}: A vector containing the cost values to be plotted.\nB0_values::Vector{Float64}: A vector of offset frequencies (in Hz) corresponding to the cost values.\n\nOutputs\n\np::Plot: A plot object displaying the cost function offset profile.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.plot_cost_values-Tuple{Vector{Float64}, GrapeParams}","page":"API","title":"GrapeMR.plot_cost_values","text":"plot_cost_values(cost::Vector{Float64}, gp::GrapeParams)\n\nPlot the cost function convergence over iterations during the GRAPE optimization process.\n\nArguments\n\ncost::Vector{Float64}: A vector containing the cost values at each iteration.\ngp::GrapeParams: The parameters of the GRAPE optimization, including the cost function name.\n\nReturns\n\nA plot object displaying the convergence of the cost function over the iterations.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.plot_longitudinal_time-Tuple{Vector{Isochromat}, Float64}","page":"API","title":"GrapeMR.plot_longitudinal_time","text":"plot_longitudinal_time(isos::Vector{Isochromat}, t::Float64)\n\nPlots the longitudinal magnetization (Mz) as a function of time for a set of isochromats.\n\nArguments\n\nisos::Vector{Isochromat}: A vector of Isochromat objects containing magnetization and spin data.\nt::Float64: Total time duration for the plot.\n\nReturns\n\npLongTime: A plot object displaying Mz as a function of time for each isochromat.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.plot_magnetization_2D-Tuple{Vector{Isochromat}}","page":"API","title":"GrapeMR.plot_magnetization_2D","text":"plot_magnetization_2D(isos::Vector{Isochromat})\n\nPlots the 2D magnetization, showing transverse (Mxy) vs longitudinal (Mz) magnetization.\n\nArguments\n\nisos::Vector{Isochromat}: A vector of Isochromat objects containing magnetization and spin data.\n\nReturns\n\npMag2D: A plot object displaying the transverse (Mxy) vs longitudinal (Mz) magnetization.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.plot_magnetization_3D-Tuple{Vector{Isochromat}}","page":"API","title":"GrapeMR.plot_magnetization_3D","text":"plot_magnetization_3D(isos::Vector{Isochromat})\n\nPlots the 3D magnetization (Mx, My, Mz) for a set of isochromats.\n\nArguments\n\nisos::Vector{Isochromat}: A vector of Isochromat objects containing magnetization and spin data.\n\nReturns\n\npMag3D: A plot object displaying the 3D magnetization components (Mx, My, Mz) for each isochromat.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.plot_magnetization_control_field-Tuple{ControlField, Vector{Isochromat}}","page":"API","title":"GrapeMR.plot_magnetization_control_field","text":"plot_magnetization_control_field(cf::ControlField, isos::Vector{Isochromat})\n\nPlot the magnetization trajectory for a set of isochromats and the corresponding control field.\n\nArguments\n\ncf::ControlField: The control field object containing the RF waveform data (B1x, B1y components).\nisos::Vector{Isochromat}: A vector of isochromat objects representing different spin systems.\n\nReturns\n\nA plot object displaying:\nThe magnetization trajectory in the transverse plane.\nThe control field amplitude and phase over time.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.plot_magnetization_time-Tuple{Isochromat, Float64}","page":"API","title":"GrapeMR.plot_magnetization_time","text":"plot_magnetization_time(iso::Isochromat, t::Float64)\n\nPlots the time evolution of magnetization components (Mx, My, Mz) for a single isochromat.\n\nArguments\n\niso::Isochromat: An Isochromat object containing magnetization dynamics.\nt::Float64: Total time duration of the plot.\n\nReturns\n\npMagTime: A plot object displaying Mx, My, and Mz as functions of time.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.plot_transverse_magnetization-Tuple{Vector{Isochromat}}","page":"API","title":"GrapeMR.plot_transverse_magnetization","text":"plot_transverse_magnetization(isos::Vector{Isochromat})\n\nPlots the transverse magnetization (Mx and My) for a set of isochromats, with colors indicating different spin targets.\n\nArguments\n\nisos::Vector{Isochromat}: A vector of Isochromat objects containing magnetization and spin information.\n\nReturns\n\npTrans: A plot object displaying the transverse magnetization (Mx vs My) for each isochromat.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.plot_transverse_time-Tuple{Vector{Isochromat}, Float64}","page":"API","title":"GrapeMR.plot_transverse_time","text":"plot_transverse_time(isos::Vector{Isochromat}, t::Float64)\n\nPlots the transverse magnetization (Mxy) as a function of time for a set of isochromats.\n\nArguments\n\nisos::Vector{Isochromat}: A vector of Isochromat objects containing magnetization and spin data.\nt::Float64: Total time duration for the plot.\n\nReturns\n\npTransTime: A plot object displaying Mxy as a function of time for each isochromat.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.random_hyperopt-Tuple{Vector{<:Spins}, GrapeParams, LinRange, StepRange}","page":"API","title":"GrapeMR.random_hyperopt","text":"random_hyperopt(spins::Vector{<:Spins}, \n                gp::GrapeParams, \n                Tc::LinRange, \n                max_iter::StepRange; \n                i::Int = 50, \n                poly_start::Vector{Float64} = [5e-1, 1e-1, 1e-2], \n                poly_degree::Vector{Int} = [1, 2], \n                B1ref::Float64 = 1.0)\n\nPerforms random sampling for hyperparameter optimization.\n\nArguments\n\nspins::Vector{<:Spins}: A vector of spin systems for the optimization process.\ngp::GrapeParams: GRAPE algorithm parameters, including cost function and fields to optimize.\nTc::LinRange: Range for time control points for spline interpolation.\nmax_iter::StepRange: Range for maximum optimization iterations.\ni::Int=50: Number of random samples to evaluate.\npoly_start::Vector{Float64}: Initial values for polynomial learning rate.\npoly_degree::Vector{Int}: Degrees for the polynomial learning rate.\nB1ref::Float64=1.0: Reference B1 field amplitude.\n\nReturns\n\nA hyperparameter optimization object with randomly sampled configurations and their costs.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.run_cost_analysis-Tuple{ControlField, Spins, Float64, Int64, Function}","page":"API","title":"GrapeMR.run_cost_analysis","text":"run_cost_analysis(grape_output::GrapeOutput, offset::Float64, b1_inhomogeneity_percent::Int)\n\nRuns a complete cost analysis for the specified GrapeOutput object over a range of B0 and B1 inhomogeneities,  and generates plots to visualize the cost function.\n\nArguments\n\ncontrol_field::ControlField: The control field object that contains the RF pulse sequence.\nspin_system::Spin: The spin system for which the cost function is to be calculated.\noffset::Float64: The range of offset frequencies (in Hz) for the B0 inhomogeneities.\nb1_inhomogeneity_percent::Int: The percentage of B1 inhomogeneity to consider for the analysis.\n\nWorkflow\n\nGenerates a range of B0 values from -offset to offset.\nComputes cost values for the specified B0 and B1 inhomogeneities using cost_offsets and create_cost_matrix.\nPlots the cost function offset profile using plot_cost_offset.\nGenerates a heatmap of the cost matrix using heatmap_cost.\nCreates a contour plot of the cost matrix using countour_cost.\n\nExample\n\nruncostanalysis(grape_output, 50.0, 30)\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.run_grape_optimization-Tuple{String}","page":"API","title":"GrapeMR.run_grape_optimization","text":"run_grape_optimization(config_path::String)\n\nRuns the GRAPE optimization process based on a TOML configuration file. Initializes spins, sets up parameters, executes optimization, and optionally saves and plots the results.\n\nArguments\n\nconfig_path::String: Path to the TOML configuration file containing parameters for spins, optimization, and control fields.\n\nConfiguration File Structure\n\nThe TOML configuration file should include sections like:     - spins: Defines spin properties.     - grape_parameters: Parameters for the GRAPE optimization.     - optimization_parameters: Parameters for the hyperparameter optimization.     - control_field: Control field specifications.     - save_files: Settings for saving outputs.     - plot: Plot settings.\n\nReturns\n\nProduces and saves results depending on configuration settings, including optimized control fields, cost values, optional Bruker export, and plots.\n\nExample\n\n```julia rungrapeoptimization(\"path/to/config.toml\")\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.save_grape_data-Tuple{GrapeOutput}","page":"API","title":"GrapeMR.save_grape_data","text":"save_output_data(go::GrapeMR.GrapeOutput; folder_path = pwd())\n\nSave data related to GRAPE optimization into a folder organized by date.\n\nArguments\n\ngo::GrapeMR.GrapeOutput: The output from a GRAPE optimization process.\nfolder_path::String = pwd(): The folder path where data will be saved. Defaults to the current working directory.\n\nOutput\n\nReturns the full path to the folder where the data was saved.\n\nSaved Files\n\ngrape_output.jld2: Contains the entire GrapeOutput struct in JLD2 format.\ndict_cost_values.csv: CSV file containing the cost values from the optimization process.\ndict_control_field.csv: CSV file containing control field values (B1x, B1y, Bz, and RF time).\ndict_iso_spins.csv: CSV file containing isochromat spin parameters.\n\nIf no path is provided, it saves the files inside the folder where the package was installed folder name format : yyyy-mm-dd\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.save_hyperopt_data-Tuple{Any}","page":"API","title":"GrapeMR.save_hyperopt_data","text":"save_output_data(bohb::GrapeMR.GrapeOutput; folder_path = pwd())\n\nSave data related to BOHB optimization into a folder organized by date.\n\nArguments\n\nbohb::GrapeMR.GrapeOutput: The output from a BOHB optimization process.\nfolder_path::String = pwd(): The folder path where data will be saved. Defaults to the current working directory.\n\nOutput\n\nReturns the full path to the folder where the data was saved.\n\nSaved Files\n\nbohb.jld2: Contains BOHB result in JLD2 format.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.sinc_RF-Tuple{Int64, Float64, Float64}","page":"API","title":"GrapeMR.sinc_RF","text":"sinc_RF(N::Int, t_c::Float64, B1ref::Float64; α=π/2)\n\nGenerates a sinc RF pulse with a specified flip angle. Bandwidth hardcoded to 100 Hz. B1x and B1y have a π/2 phase difference\n\nArguments\n\nN::Int: Number of time points.\nt_c::Float64: Duration of the pulse in seconds.\nB1ref::Float64: Reference amplitude for scaling the pulse.\nα::Float64=π/2: Flip angle in radians.\n\nReturns\n\nA ControlField struct with B1x, B1y, and Bz components generated as sinc functions.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.spline_RF-Tuple{Any, Any, Any}","page":"API","title":"GrapeMR.spline_RF","text":"spline_RF(N::Int, t_c::Float64, B1ref::Float64)\n\nGenerates a cubic spline-based RF pulse.\n\nArguments\n\nN::Int: Number of time points.\nt_c::Float64: Duration of the pulse in seconds.\nB1ref::Float64: Reference amplitude for scaling the pulse.\n\nReturns\n\nA ControlField struct with B1x, B1y, and Bz components generated using spline interpolation.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.steady_state-Tuple{SteadyState}","page":"API","title":"GrapeMR.steady_state","text":"steady_state(s::GrapeMR.SteadyState)\n\nCalculates the steady-state signal of a bSSFP sequence for a given set of parameters. The function calculates the magnetization evolution  using repeated RF excitations and free precession steps until the steady state is reached.\n\nArguments\n\ns::GrapeMR.SteadyState: A struct containing TR (Repetition Time), TE (Echo Time), T1 (Spin-lattice relaxation time),                            T2 (Spin-spin relaxation time), α (Flip angle in radians), Δϕ (Phase cycling increment),                            M_init (Initial magnetization vector), and B0inho (B0 inhomogeneity).\n\nOutputs\n\nsignal::Vector{ComplexF64}: The complex steady-state signal of the spin system.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.steady_state_geometric-Tuple{SteadyState}","page":"API","title":"GrapeMR.steady_state_geometric","text":"steady_state_geometric(s::GrapeMR.SteadyState)\n\nCalculates the transverse steady-state magnetization using a geometric solution for a bSSFP sequence. Uses a geometric approach to  derive the transverse component of the steady-state magnetization.\n\nArguments\n\ns::GrapeMR.SteadyState: Struct containing the sequence parameters and spin system properties.\n\nOutputs\n\nMxy::Vector{Float64}: The steady-state transverse magnetization magnitude Mxy\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.steady_state_geometric_Mz-Tuple{SteadyState}","page":"API","title":"GrapeMR.steady_state_geometric_Mz","text":"steady_state_geometric_Mz(s::GrapeMR.SteadyState)\n\nCalculates the longitudinal steady-state magnetization using a geometric solution for a bSSFP sequence. Uses a geometric approach to  derive the longitudinal component of the steady-state magnetization.\n\nArguments\n\ns::GrapeMR.SteadyState: Struct containing the sequence parameters and spin system properties.\n\nOutputs\n\nMz::Vector{Float64}: The steady-state longitudinal magnetization magnitude Mz\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.update!-Tuple{ControlField, Tuple{Matrix{Float64}, Matrix{Float64}}, Float64}","page":"API","title":"GrapeMR.update!","text":"update!(cf::ControlField, ∇xy::Tuple, ϵ::Float64)\n\nUpdates the control fields based on the calculated gradient and a learning rate.\n\nArguments\n\ncf::ControlField: Control field struct to be updated.\n∇xy::Tuple{Matrix{Float64}, Matrix{Float64}}: Gradients for the x and y components of the field.\nϵ::Float64: Learning rate for gradient descent.\n\nReturns\n\n(u1x, u1y): Updated x and y control fields.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.ControlField","page":"API","title":"GrapeMR.ControlField","text":"ControlField{T, M1, Mz}\n\nRepresents the RF control field parameters for an NMR/MRI sequence.\n\nFields\n\nB1x::M1: Matrix for the x-component of the RF field.\nB1y::M1: Matrix for the y-component of the RF field.\nB1_ref::T: Reference amplitude of the RF field.\nBz::Mz: Matrix for the z-component of the magnetic field.\nt_control::T: Total control time for the sequence.\n\n\n\n\n\n","category":"type"},{"location":"api/#GrapeMR.GrapeOutput","page":"API","title":"GrapeMR.GrapeOutput","text":"GrapeOutput{T, M1, Mz, F}\n\nStores the output of GRAPE optimization.\n\nFields\n\nisochromats::Vector{Isochromat}: Vector of isochromats containing the spin dynamics.\ncontrol_field::ControlField{T, M1, Mz}: Optimized control field after GRAPE optimization.\ncost_values::Vector{Float64}: Sequence of cost function values at each iteration.\nparams::Parameters{F}: Struct containing GRAPE parameters and optimization parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#GrapeMR.GrapeParams","page":"API","title":"GrapeMR.GrapeParams","text":"GrapeParams{F}\n\nEncapsulates key parameters for the GRAPE optimization process.\n\nFields\n\nN::Int64: Number of time steps in the control sequence.\ncost_function::F: Function used to compute the optimization cost.\nfields_opt::Dict{String, Bool}: Dictionary indicating which fields to optimize (e.g., B1x, B1y).\n\n\n\n\n\n","category":"type"},{"location":"api/#GrapeMR.Isochromat","page":"API","title":"GrapeMR.Isochromat","text":"Isochromat{S}\n\nRepresents an isochromat, combining magnetization data with a specific spin configuration.\n\nFields\n\nmagnetization::Magnetization: Magnetization data associated with a collection or single isochromat.\nspin::S: Spin configuration for a collection or single isochromat.\n\n\n\n\n\n","category":"type"},{"location":"api/#GrapeMR.Magnetization","page":"API","title":"GrapeMR.Magnetization","text":"Magnetization{T, M}\n\nRepresents the magnetization dynamics of a spin system.\n\nFields\n\ndynamics::M: Time-evolution data for magnetization, either as a 4xN matrix.\n\n\n\n\n\n","category":"type"},{"location":"api/#GrapeMR.OptimizationParams","page":"API","title":"GrapeMR.OptimizationParams","text":"OptimizationParams\n\nDefines parameters for polynomial-based decay for ϵ in the GRAPE algorithm.\n\nFields\n\npoly_start::Float64: Initial polynomial coefficient.\npoly_degree::Int: Degree of the polynomial.\nmax_iter::Int: Maximum number of optimization iterations.\n\n\n\n\n\n","category":"type"},{"location":"api/#GrapeMR.Parameters","page":"API","title":"GrapeMR.Parameters","text":"Parameters{F}\n\nCombines GRAPE and optimization parameters for the full optimization process.\n\nFields\n\ngrape_params::GrapeParams{F}: GRAPE-specific optimization parameters.\nopt_params::OptimizationParams: General optimization parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#GrapeMR.Spin","page":"API","title":"GrapeMR.Spin","text":"Spin <: Spins\n\nGets relaxation parameters and inhomogeneity effects of the spin system.\n\nFields\n\nM_init::Vector{Float64}: Initial magnetization vector.\nT1::Float64: Longitudinal relaxation time.\nT2::Float64: Transverse relaxation time.\nB0inho::Float64: B0 inhomogeneity.\nB1inho::Float64: B1 inhomogeneity.\ntarget::String: Target magnetization state.\nlabel::String: Label for identifying the spin.\nNspins::Float64: Number of spins in this configuration.\n\n\n\n\n\n","category":"type"},{"location":"api/#GrapeMR.Spin-NTuple{7, Any}","page":"API","title":"GrapeMR.Spin","text":"Spin(M_ini, T1, T2, B0, B1, targets, labels)\n\nConstructs a collection of Spin instances with specified parameters.\n\nArguments\n\nM_ini::Vector{Float64}: Initial magnetization vector.\nT1::Vector{Float64}: Longitudinal relaxation times.\nT2::Vector{Float64}: Transverse relaxation times.\nB0::Vector{Float64}: Array of B0 inhomogeneity values.\nB1::Vector{Float64}: Array of B1 inhomogeneity values.\ntargets::Vector{String}: Target states for each spin configuration.\nlabels::Vector{String}: Labels for each spin configuration.\n\nReturns\n\nA vector of Spin instances covering all combinations of the provided parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.Spins","page":"API","title":"GrapeMR.Spins","text":"Spins\n\nAbstract type representing a generic spin system in NMR/MRI.\n\n\n\n\n\n","category":"type"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"../tutorial.jl\"","category":"page"},{"location":"generated/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"The goal is to show how to implement the GrapeMR.jl package","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"Define your physical system: Spins, relaxation values, inhomogeneities, etc.\nOptimization parameters: Scheduler parameters, max iterations, etc.\nGrape Parameters: Time steps, cost function and which fields to optimize.\nGenerate initial control field: Spline","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"using GrapeMR","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"Physical system: Initial magnetization state, relaxation values in seconds, label are the spins names, target: cost function dependent, B0 inhomonegenty in Herz. At the end, create the spin object with all spins","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"M0 = [0.0, 0.0, 1.0]\nT1 = [1.3, 0.73]\nT2 = [2.0, 0.04]\nlabel  = [\"T1=$(T1[1]*1e3)ms\", \"T1=$(T1[2]*1e3)ms\"]\ntarget = [\"min\", \"max\"]\nB0 = 30.0\noffset = collect(-B0/2:5:B0/2)\nΔB1 = [1.0]\nspins = Spin(M0, T1, T2, offset, ΔB1, target, label)","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"Optimization Parameters:","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"max_iter = get(ENV, \"DEV\", \"false\") == \"true\" ? 1 : 2000  # we set max_iter to 1 if we're in development mode to build the docs faster\nTc, poly_start, poly_degree = 0.836, 0.1, 1\nopt_params = OptimizationParams(poly_start, poly_degree, Int(ceil(max_iter)))","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"Grape Parameters","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"grape_params = GrapeParams(1500, GrapeMR.saturation_contrast_Mx, Dict(\"B1x\" => true, \"B1y\" => true, \"Bz\" => false))","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"RF","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"N = 1500\nB1ref = 1.0\ncontrol_field = spline_RF(N, Tc, B1ref)","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"Run Optimization","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"params = Parameters(grape_params, opt_params)\ngrape_output = grape(params, control_field, spins);\nnothing #hide","category":"page"},{"location":"generated/tutorial/#Plots","page":"Tutorial","title":"Plots","text":"","category":"section"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"using GrapeMR, Plots; unicodeplots(); # change the backend so that plots go to stdout and can be rendered in CI/headless mode.\ndefault(show = false); #hide\ncontrol_fields = plot_control_fields(grape_output.control_field);\ndisplay(control_fields)","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"The Spin struct:","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"[(k, v) for (k, v) in zip(fieldnames(GrapeMR.Spin), fieldtypes(GrapeMR.Spin))]","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#GrapeMR.jl","page":"Introduction","title":"GrapeMR.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Grape Logo)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Documentation for GrapeMR.jl","category":"page"},{"location":"#Magnetic-systems","page":"Introduction","title":"Magnetic systems","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Given a homogeneus magnetic field vecB_0 = B_0textbfz \nMagnetic moments align with vecB_0 resulting in a bulk magnetization M_0 along the z-axis.\nThe presence of vecB_0 gives raise (?) to a resonance condition specific for each atomic nuclei.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"omega_0 = -gamma B_0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where omega_0 [rads/s] is the Larmor frequency, gamma [rads/s/T]  the gyromagnetic ratio and B_0 [T] the homogenios magnetic field. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"An inhomogeneous magnetic field B_1(t), perpendicular to B_0, when irradiated in the resonance frequency, rotates the magnetization. The rotation angle is described as, ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"alpha = 2 pi gamma B_1 Delta t","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where Delta t is the duration of the B_1(t) field. Because the gyromagnetic ratio of the proton is O(MHz), so is the B_1(t), hence, radio frequency field. It can be rewritten as a combination of its x-y components, B_1(t) = B_1x + i B_1y. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Once B_1(t) is turned off, the system starts to relax back to equilibrium, generating a signal called FID (Free Induction Decay).\nThe relaxation parameters, T_1 and T_2, are individual to each molecule, therefore, generating different decays for different molecules excited by the same RF pulse.\nFrom the signal detected, one can calculate the magnetization values.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<!– ","category":"page"},{"location":"#Optimal-Control","page":"Introduction","title":"Optimal Control","text":"","category":"section"},{"location":"#Description-of-System-Dynamics","page":"Introduction","title":"Description of System Dynamics","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The dynamics of a system can be mathematically described by the following system of equations:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"begincases\n    dotvecx(t) = vecf(x(t)) \n    x(0) = x_0 (t  0)\nendcases","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Here, vecf represents all of the forces acting on the system. In a control dynamics, a function u(t), called the control function, is introduced to allow for manipulation of the system. The system dynamics can now be written as:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"begincases\n    dotvecx(t) = vecf(x(t) u(t)) \n    x(0) = x_0 (t  0) \nendcases","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The goal in this type of system is to find the \"best set\" of controls. To achieve this, a reward function C is introduced. If u^*(t) is the optimal control, then for all u(t), the reward function satisfies:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"C(u^*)  C(u)","category":"page"},{"location":"#Optimal-Control-in-NMR","page":"Introduction","title":"Optimal Control in NMR","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"In Nuclear Magnetic Resonance (NMR), a controled dynamics can be achieved by designing the RF pulses as the controls. Hence, the magnetization dynamics would be proportional to,","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"dotM(t) = f(M_0 T_1 T_2 B_1(t) M(t))","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"More specifically, the dynamics are governed by the Bloch Equations, which can be expressed as follows:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"beginbmatrix\n    dotM_x  dotM_y  dotM_z\nendbmatrix = \nbeginbmatrix\n    -1T_2  Delta B_0  -B1_y \n    -Delta B_0  -1T_2  B1_x \n    B1_y  -B1_x  1T_1\nendbmatrix\nbeginbmatrix\n    M_x  M_y  M_z\nendbmatrix + \nbeginbmatrix\n    0  0  M_0T_1\nendbmatrix","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where the dynamics of the magnetization is described by the vector vecM = (M_x M_y M_z). ","category":"page"},{"location":"#Cost-Function","page":"Introduction","title":"Cost Function","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Defining a cost function is essencial in this processes since it is based on it that the system will be optimized. In the case of contrast saturation, given two samples a and b, the goal is to supress one signal while maximizing the other. This can be achieved using the following cost function:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"C^(ab) = vecM^(b)(t_f) - (M_z^(a)(t_f))^2","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This cost function yields the best value of -1 when the signal of sample a is zero and the signal of sample b is maximum.","category":"page"},{"location":"#GRAPE-Algorithm","page":"Introduction","title":"GRAPE Algorithm","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The basic algorithm for optimization is Gradient Ascent, which can be described using the following steps:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Choose an initial control field (can be an arbitrary smart guess);\nCompute the cost function C(u);\nCompute the gradient fracdelta Cdelta u;\nUpdate the current control field using the formula: vecomega^(n + 1) = vecomega^(n) - gamma fracdelta Cdelta u;\nRepeat 2-4 until convergence.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"While this is the simplest way to apply the gradient ascent algorithm, a more precise approach involves using forward and backward propagation to update the control field. This approach will be discussed in the following section.  –>","category":"page"}]
}
