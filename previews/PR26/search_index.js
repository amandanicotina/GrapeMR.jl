var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"N. Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbrüggen and S. J. Glaser. Optimal control of coupled spin dynamics: design of NMR pulse sequences by gradient ascent algorithms. Journal of magnetic resonance 172, 296–305 (2005).\n\n\n\n","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [GrapeMR]\nOrder   = [:function, :type]","category":"page"},{"location":"api/#GrapeMR.RF_pulse_analysis-Tuple{ControlField}","page":"API","title":"GrapeMR.RF_pulse_analysis","text":"RF_pulse_analysis(cf::ControlField; attenuation_ref = 0.0, B1_ref = 1.0, power_ref = 500.0)\n\nCalculate calibration analysis of shaped pulse\n\nArguments\n\ncf::ControlField: The control field object containing the RF waveform.\nattenuation_ref::Float64: Reference attenuation in dB (default is 0.0 dB).\nB1_ref::Float64: Reference RF field strength in Tesla (default is 1.0 T).\npower_ref::Float64: Reference RF power in Watts (default is 500.0 W).\n\nOutputs:\n\nA tuple of calculated values:\n\nmax_amp: Maximum RF amplitude in Hertz (Hz).\nmax_amp_tesla: Maximum RF amplitude in microtesla (µT).\nattenuation_B1: Attenuation in decibels (dB).\npower_max_B1: Maximum power in Watts (W).\npower_average: Average power in Watts (W).\npulse_energy: Pulse energy in Joules (J).\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.amplitudes_and_phases-Tuple{ControlField}","page":"API","title":"GrapeMR.amplitudes_and_phases","text":"amplitudes_and_phases(cf::ControlField)\n\nCalculates amplitudes and phases in Hz and radians\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.bSSFP_RF-Tuple{Int64, Int64, Real, Float64}","page":"API","title":"GrapeMR.bSSFP_RF","text":"bSSFP_RF(N::Int, nTR::Int, α::Real, TR::Float64)\n\nGenerates a bSSFP pulse sequence with bandwidth BW and flip angle flip_angle in radians\n\nArguments\n\nN::Int: Points\nnTR::Int: How many TRs\nα::Real: Flip angle\n`TR::Float64: Repetition time TR in seconds\n\nOutput\n\nNx1 array with bSSFP pulse amplitudes\n\nExample\n\n```julia bSSFP(gpoutput, folderpath=\"/path/to/folder\")\n\nIf no path is provided, it saves the files inside the folder where the package was installed folder name format : yyyy-mm-dd\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.bandwidth_factor-Tuple{}","page":"API","title":"GrapeMR.bandwidth_factor","text":"bandwidth_factor(cf::ControlField)\n\nExcitation frequency range\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.bloch_matrix-NTuple{5, Float64}","page":"API","title":"GrapeMR.bloch_matrix","text":"bloch_matrix(B1x::Float64, B1y::Float64, Bz::Float64, Γ1::Float64, Γ2::Float64)\n\nArguments\n\nB1x: (::Float64) - B1x step\nB1y: (::Float64) - B1x step\nBz:  (::Float64) - B1x step\nΓ1:  (::Float64) - B1x step\nΓ2:  (::Float64) - B1x step\n\nOutputs\n\nCalculated 4x4 Bloch matrix\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.bohb_hyperopt-Tuple{Vector{<:Spins}, GrapeParams, LinRange, Int64}","page":"API","title":"GrapeMR.bohb_hyperopt","text":"bohb_hyperopt(spins::Vector{<:Spins}, \n                  gp::GrapeParams, \n                  Tc::LinRange, \n                  max_iter::Int; \n                  i::Int=5, \n                  poly_start::Vector{Float64}=[1e-1, 1e-2], \n                  poly_degree::Vector{Int}=[1, 2, 3], \n                  B1ref::Float64=1.0)\n\nPerforms hyperparameter optimization using Bayesian Optimization and Hyperband (BOHB) for selecting hyperparameters.\n\nArguments\n\nspins::Vector{<:Spins}: A vector containing spin systems for the optimization process.\ngp::GrapeParams: Grape algorithm parameters, which include time points, cost function, and mask for which fields are being optimized.\nTc::LinRange: Range for the time control points for spline interpolation.\nmax_iter::Int: Maximum number of iterations for the optimizer.\ni::Int=5: Number of optimization evaluations.\npoly_start::Vector{Float64}=[1e-1, 1e-2]: Starting points for the polynomial learning rate.\npoly_degree::Vector{Int}=[1, 2, 3]: Degrees for the polynomial learning rate.\nB1ref::Float64=1.0: Reference B1 field amplitude for the RF pulse.\n\nOutputs\n\nAn optimized object from the BOHB optimization process, containing results and optimization history.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.bruker_normalized_amplitudes_and_phases-Tuple{ControlField}","page":"API","title":"GrapeMR.bruker_normalized_amplitudes_and_phases","text":"bruker_normalized_amplitudes_and_phases(cf::ControlField)\n\nCalculates amplitudes and phases normalized to 100 and 180 deg for Bruker implementation on TopSpin. All negative phase values are added a 360deg phase\n\nArguments\n\ncf::ControlField: The control field object containing the RF waveform.\n\nOutputs:\n\nA tuple of normalized amplitudes and phases:\n\nnorm_amp: Maximum RF amplitude in Hertz (Hz).\nnorm_phase: Normalize phases in degrees. \n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.complex_signal-Tuple{ControlField}","page":"API","title":"GrapeMR.complex_signal","text":"complex_signal(cf::ControlField)\n\nCalculates complex RF signal in Hz\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.cost_offsets-Tuple{ControlField, Spin, Vector{Float64}, Function}","page":"API","title":"GrapeMR.cost_offsets","text":"cost_offsets(control_field::ControlField, spin_system::Spin, offsets::Vector{Float64})\n\nCalculates the cost values for a given control field (control_field) and spin system (spin_system) over a range of B0 inhomogeneities (offsets).\n\nArguments\n\ncontrol_field::ControlField: The control field object that contains the RF pulse sequence.\nspin_system::Spin: The spin system for which the cost function is to be calculated.\noffsets::Vector{Float64}: A vector of offset frequencies (in Hz) representing B0 inhomogeneities.\n\nOutputs\n\ncost_values::Vector{Float64}: A vector containing the cost values corresponding to each offset in B0_values.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.countour_cost-Tuple{Matrix{Float64}, Vector{Float64}, Vector{Float64}}","page":"API","title":"GrapeMR.countour_cost","text":"countour_cost(cost_matrix::Matrix{Float64})\n\nCreates a contour plot of the cost function values over the range of B0 and B1 inhomogeneities.\n\nArguments\n\ncost_matrix::Matrix{Float64}: A 2D matrix representing the cost values for combinations of B0 and B1 inhomogeneities.\n\nOutputs\n\nc::Plot: A contour plot of the cost function map.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.create_cost_matrix-Tuple{ControlField, Spin, Vector{Float64}, Vector{Float64}, Function}","page":"API","title":"GrapeMR.create_cost_matrix","text":"create_cost_matrix(control_field::ControlField, spin_system::Spin, offsets::Vector{Float64}, b1_inhomogeneities::Vector{Float64})\n\nGenerates a cost matrix representing the cost function values across a range of B0 and B1 inhomogeneities.\n\nArguments\n\ncontrol_field::ControlField: The control field object that contains the RF pulse sequence\nspin_system::Spin: The spin system for which the cost function is to be calculated.\noffsets::Vector{Float64}: A vector of offset frequencies (in Hz) representing B0 inhomogeneities.\nb1_inhomogeneities::Vector{Float64}: A vector representing B1 inhomogeneity percentages.\n\nOutputs\n\ncost_matrix::Matrix{Float64}: A 2D matrix where each element represents the cost value for a particular                                        combination of B0 and B1 values. The matrix is normalized by its maximum value.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.create_folder-Tuple{String}","page":"API","title":"GrapeMR.create_folder","text":"create_folder(path::String)\n\nCreates a folder at the specified path if it doesn't already exist.\n\nArguments\n\npath::String: The path where the folder will be created.\n\nOutput\n\nReturns the path to the created folder. If the folder already exists, it simply returns the path.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.dynamics-Tuple{ControlField, Spins}","page":"API","title":"GrapeMR.dynamics","text":"dynamics(cf::ControlField, spins::Spin)\n\nFunction that returns the Isochromat object with the already calculated dynamics.\n\n# Input  \n- cf::ControlField - Adjoint State\n- spins::Spin\n\n# Output\n- iso::Isochromat\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.forward_propagation-Tuple{ControlField, Spins}","page":"API","title":"GrapeMR.forward_propagation","text":"forward_propagation\n\nArguments\n\ncf: (::ControlField) - Control fields struct\ns:  (::Spins) - Spin struct\n\nOutputs\n\nMagnetization vector 4xN\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.gaussian_RF-Tuple{Int64, Float64, Float64}","page":"API","title":"GrapeMR.gaussian_RF","text":"guassian_RF(N::Int, t_c::Float64, BW_Hz::Real, flip_angle::Float64)\n\nGenerates a Gaussian pulse with bandwidth BW and flip angle flip_angle in radians\n\nArguments\n\nN::Int: Points\nt_c::Float64: Shaped pulse time in seconds\nBW_Hz::Real: Pulse bandwidth\nflip_angle::Float64: Flip angle\n\nOutput\n\n1xN array with sinc pulse amplitudes\n\nExample\n\n```julia bSSFP(gpoutput, folderpath=\"/path/to/folder\")\n\nIf no path is provided, it saves the files inside the folder where the package was installed folder name format : yyyy-mm-dd\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.grape-Tuple{Parameters, ControlField, Vector{<:Spins}}","page":"API","title":"GrapeMR.grape","text":"grape(p::Parameters, cf::ControlField, spins::Vector{<:Spins})\n\nImplements the grape algorithm [1] \n\nArguments\n\nop::OptimizationParams: Parameters for the optimization itself: max iterations, \ngp::GrapeParams: Parameters related to Grape itself: time points, cost function, mask for which fields are being optimized.\ncf::ControlField: Initial control field - spline function -\nspins::Vector{<:Spins}: Vector with all spins included in the optimization\n\nOutputs\n\nA scruct cointaing all optimization results:\n\n`grape_output::GrapeOutput': Data type with the optimized control fields, spin information and spin dynamics.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.hard_RF-Tuple{Any, Any, Any}","page":"API","title":"GrapeMR.hard_RF","text":"hard_RF(N::Int, t_c::Float64)\n\nGenerates a cubic spline pulse \n\nArguments\n\nN::Int: Points\nt_c::Float64: Shaped pulse time in seconds\n\nOutput\n\n1xN array with spline pulse amplitudes\n\nExample\n\n```julia bSSFP(gpoutput, folderpath=\"/path/to/folder\")\n\nIf no path is provided, it saves the files inside the folder where the package was installed folder name format : yyyy-mm-dd\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.heatmap_cost-Tuple{Matrix{Float64}, Vector{Float64}, Vector{Float64}}","page":"API","title":"GrapeMR.heatmap_cost","text":"heatmap_cost(cost_matrix::Matrix{Float64}, offsets::Vector{Float64}, b1_inhomogeneities::Vector{Float64})\n\nGenerates a heatmap plot of the cost function values over a range of B0 and B1 inhomogeneities.\n\nArguments\n\ncost_matrix::Matrix{Float64}: A 2D matrix representing the cost values for combinations of B0 and B1 inhomogeneities.\noffsets::Vector{Float64}: A vector of offset frequencies (in Hz) used to label the x-axis.\nb1_inhomogeneities::Vector{Float64}: A vector representing B1 inhomogeneity percentages used to label the y-axis.\n\nOutputs\n\nh::Plot: A heatmap plot showing the cost function map with a color bar indicating cost values.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.integral_factor-Tuple{ControlField}","page":"API","title":"GrapeMR.integral_factor","text":"integral_factor(cf::ControlField)\n\nPower or energy of the RF pulse integrated over its duration\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.max_peak_amp-Tuple{Vector{ComplexF64}}","page":"API","title":"GrapeMR.max_peak_amp","text":"max_peak_amp(B1::Vector{ComplexF64})\n\nReturns the maximum RF amplitude in Hz\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.max_peak_amp_tesla-Tuple{Vector{ComplexF64}}","page":"API","title":"GrapeMR.max_peak_amp_tesla","text":"max_peak_amp_tesla(B1::Vector{ComplexF64})\n\nReturns the maximum RF amplitude in Tesla\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.plot_control_fields-Tuple{ControlField}","page":"API","title":"GrapeMR.plot_control_fields","text":"plot_control_fields(cf::ControlField; unit::String = \"Hz\")\n\nPlot the control fields of an RF pulse in different units.\n\nArguments\n\ncf::ControlField: The control field object containing the RF waveform data (B1x, B1y components).\nunit::String: The unit for the plot. Supported units are:\n\"Hz\": Plots B1x and B1y in Hertz.\n\"rad/s\": Converts the control fields to rads/sec and plots the amplitude and phase.\n\"Tesla\": Converts the control fields to Tesla using the gyromagnetic ratio for ¹H and plots in microtesla (µT).\n\nOutputs\n\nA plot object displaying the control fields in the specified units with amplitude and phase information.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.plot_cost_offset-Tuple{Vector{Float64}, Vector{Float64}}","page":"API","title":"GrapeMR.plot_cost_offset","text":"plot_cost_offset(cost_profile::Vector{Float64}, B0_values::Vector{Float64})\n\nCreates a plot of the cost values as a function of B0 offset frequencies.\n\nArguments\n\ncost_profile::Vector{Float64}: A vector containing the cost values to be plotted.\nB0_values::Vector{Float64}: A vector of offset frequencies (in Hz) corresponding to the cost values.\n\nOutputs\n\np::Plot: A plot object displaying the cost function offset profile.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.plot_cost_values-Tuple{Vector{Float64}, GrapeParams}","page":"API","title":"GrapeMR.plot_cost_values","text":"plot_cost_values(cost::Vector{Float64}, gp::GrapeParams)\n\nPlot the cost function convergence over iterations during the GRAPE optimization process.\n\nArguments\n\ncost::Vector{Float64}: A vector containing the cost values at each iteration.\ngp::GrapeParams: The parameters of the GRAPE optimization, including the cost function name.\n\nOutputs\n\nA plot object displaying the convergence of the cost function over the iterations.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.plot_magnetization_control_field-Tuple{ControlField, Vector{Isochromat}}","page":"API","title":"GrapeMR.plot_magnetization_control_field","text":"plot_magnetization_control_field(cf::ControlField, isos::Vector{Isochromat})\n\nPlot the magnetization trajectory for a set of isochromats and the corresponding control field.\n\nArguments\n\ncf::ControlField: The control field object containing the RF waveform data (B1x, B1y components).\nisos::Vector{Isochromat}: A vector of isochromat objects representing different spin systems.\n\nOutputs\n\nA plot object displaying:\nThe magnetization trajectory in the transverse plane.\nThe control field amplitude and phase over time.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.plot_transverse_magnetization-Tuple{Vector{Isochromat}}","page":"API","title":"GrapeMR.plot_transverse_magnetization","text":"2D Magnetization Plots\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.random_hyperopt-Tuple{Vector{<:Spins}, GrapeParams, LinRange, StepRange}","page":"API","title":"GrapeMR.random_hyperopt","text":"random_sampler(spins::Vector{<:Spins}, \n              gp::GrapeParams, \n              Tc::LinRange, \n              max_iter::StepRange; \n              i::Int=50, \n              poly_start::Vector{Float64}=[1e-1, 1e-2], \n              poly_degree::Vector{Int}=[1, 2, 3], \n              B1ref::Float64=1.0)\n\nPerforms random sampling for hyperparameter optimization.\n\nArguments\n\nspins::Vector{<:Spins}: A vector containing spin systems for the optimization process.\ngp::GrapeParams: Grape algorithm parameters, which include time points, cost function, and mask for which fields are being optimized.\nTc::LinRange: Range for the time control points for spline interpolation.\nmax_iter::StepRange: Range for the maximum number of iterations for the optimizer.\ni::Int=50: Number of random samples to evaluate.\npoly_start::Vector{Float64}=[1e-1, 1e-2]: Starting points for the polynomial learning rate.\npoly_degree::Vector{Int}=[1, 2, 3]: Degrees for the polynomial learning rate.\nB1ref::Float64=1.0: Reference B1 field amplitude for the RF pulse.\n\nOutputs\n\nA random hyperparameter optimization object using random sampling.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.run_cost_analysis-Tuple{ControlField, Spins, Float64, Int64, Function}","page":"API","title":"GrapeMR.run_cost_analysis","text":"run_cost_analysis(grape_output::GrapeOutput, offset::Float64, b1_inhomogeneity_percent::Int)\n\nRuns a complete cost analysis for the specified GrapeOutput object over a range of B0 and B1 inhomogeneities,  and generates plots to visualize the cost function.\n\nArguments\n\ncontrol_field::ControlField: The control field object that contains the RF pulse sequence.\nspin_system::Spin: The spin system for which the cost function is to be calculated.\noffset::Float64: The range of offset frequencies (in Hz) for the B0 inhomogeneities.\nb1_inhomogeneity_percent::Int: The percentage of B1 inhomogeneity to consider for the analysis.\n\nWorkflow\n\nGenerates a range of B0 values from -offset to offset.\nComputes cost values for the specified B0 and B1 inhomogeneities using cost_offsets and create_cost_matrix.\nPlots the cost function offset profile using plot_cost_offset.\nGenerates a heatmap of the cost matrix using heatmap_cost.\nCreates a contour plot of the cost matrix using countour_cost.\n\nExample\n\nruncostanalysis(grape_output, 50.0, 30)\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.run_grape_optimization-Tuple{String}","page":"API","title":"GrapeMR.run_grape_optimization","text":"run_grape_optimization(config_path::String)\n\nThis function runs the GRAPE optimization process for an NMR/MRI system based on a given configuration file. The function initializes spin systems, sets up optimization parameters, and executes the optimization using the GRAPE algorithm. The results are optionally saved and plotted based on the configuration file.\n\nArguments\n\nconfig_path::String:    Path to the TOML configuration file. This file should contain all necessary parameters for spins, optimization, and control fields.\n\nConfiguration File Structure\n\nThe configuration file should follow the TOML format and include the following sections:\n\n- **spins**:\n- **grape_parameters**:\n- **optimization_parameters**:\n- **control_field**:\n- **save_files**:\n- **plot**:\n\nOutputs\n\nThe function produces several outputs depending on the configuration:\n- GRAPE optimization results, including optimized control fields and cost values.\n- Hyperparameter optimization results, if enabled.\n- Optional saving of output data and Bruker export.\n- Plots visualizing the magnetization and control fields over time.\n\nExample\n\n```julia rungrapeoptimization(\"path/to/config.toml\")\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.save_grape_data-Tuple{GrapeOutput}","page":"API","title":"GrapeMR.save_grape_data","text":"save_output_data(go::GrapeMR.GrapeOutput; folder_path = pwd())\n\nSave data related to GRAPE optimization into a folder organized by date.\n\nArguments\n\ngo::GrapeMR.GrapeOutput: The output from a GRAPE optimization process.\nfolder_path::String = pwd(): The folder path where data will be saved. Defaults to the current working directory.\n\nOutput\n\nReturns the full path to the folder where the data was saved.\n\nSaved Files\n\ngrape_output.jld2: Contains the entire GrapeOutput struct in JLD2 format.\ndict_cost_values.csv: CSV file containing the cost values from the optimization process.\ndict_control_field.csv: CSV file containing control field values (B1x, B1y, Bz, and RF time).\ndict_iso_spins.csv: CSV file containing isochromat spin parameters.\n\nIf no path is provided, it saves the files inside the folder where the package was installed folder name format : yyyy-mm-dd\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.save_hyperopt_data-Tuple{Any}","page":"API","title":"GrapeMR.save_hyperopt_data","text":"save_output_data(bohb::GrapeMR.GrapeOutput; folder_path = pwd())\n\nSave data related to BOHB optimization into a folder organized by date.\n\nArguments\n\nbohb::GrapeMR.GrapeOutput: The output from a BOHB optimization process.\nfolder_path::String = pwd(): The folder path where data will be saved. Defaults to the current working directory.\n\nOutput\n\nReturns the full path to the folder where the data was saved.\n\nSaved Files\n\nbohb.jld2: Contains BOHB result in JLD2 format.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.sinc_RF-Tuple{Int64, Float64, Float64}","page":"API","title":"GrapeMR.sinc_RF","text":"sinc_RF(N::Int, t_c::Float64, BW_Hz::Real, flip_angle::Float64)\n\nGenerates a sinc pulse with bandwidth BW and flip angle flip_angle in radians\n\nArguments\n\nN::Int: Points\nt_c::Float64: Shaped pulse time in seconds\nBW_Hz::Real: Pulse bandwidth\nflip_angle::Float64: Flip angle\n\nOutput\n\n1xN array with sinc pulse amplitudes\n\nExample\n\n```julia bSSFP(gpoutput, folderpath=\"/path/to/folder\")\n\nIf no path is provided, it saves the files inside the folder where the package was installed folder name format : yyyy-mm-dd\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.spline_RF-Tuple{Any, Any, Any}","page":"API","title":"GrapeMR.spline_RF","text":"spline_RF(N::Int, t_c::Float64)\n\nGenerates a cubic spline pulse \n\nArguments\n\nN::Int: Points\nt_c::Float64: Shaped pulse time in seconds\nB1_ref::Float64: Reference, normally pulse maximum amplitude\n\nOutput\n\nControlField struct \n\nExample\n\n```julia bSSFP(gpoutput, folderpath=\"/path/to/folder\")\n\nIf no path is provided, it saves the files inside the folder where the package was installed folder name format : yyyy-mm-dd\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.steady_state-Tuple{SteadyState}","page":"API","title":"GrapeMR.steady_state","text":"steady_state(s::GrapeMR.SteadyState)\n\nCalculates the steady-state signal of a bSSFP sequence for a given set of parameters. The function calculates the magnetization evolution  using repeated RF excitations and free precession steps until the steady state is reached.\n\nArguments\n\ns::GrapeMR.SteadyState: A struct containing TR (Repetition Time), TE (Echo Time), T1 (Spin-lattice relaxation time),                            T2 (Spin-spin relaxation time), α (Flip angle in radians), Δϕ (Phase cycling increment),                            M_init (Initial magnetization vector), and B0inho (B0 inhomogeneity).\n\nOutputs\n\nsignal::Vector{ComplexF64}: The complex steady-state signal of the spin system.\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.steady_state_geometric-Tuple{SteadyState}","page":"API","title":"GrapeMR.steady_state_geometric","text":"steady_state_geometric(s::GrapeMR.SteadyState)\n\nCalculates the transverse steady-state magnetization using a geometric solution for a bSSFP sequence. Uses a geometric approach to  derive the transverse component of the steady-state magnetization.\n\nArguments\n\ns::GrapeMR.SteadyState: Struct containing the sequence parameters and spin system properties.\n\nOutputs\n\nMxy::Vector{Float64}: The steady-state transverse magnetization magnitude Mxy\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.steady_state_geometric_Mz-Tuple{SteadyState}","page":"API","title":"GrapeMR.steady_state_geometric_Mz","text":"steady_state_geometric_Mz(s::GrapeMR.SteadyState)\n\nCalculates the longitudinal steady-state magnetization using a geometric solution for a bSSFP sequence. Uses a geometric approach to  derive the longitudinal component of the steady-state magnetization.\n\nArguments\n\ns::GrapeMR.SteadyState: Struct containing the sequence parameters and spin system properties.\n\nOutputs\n\nMz::Vector{Float64}: The steady-state longitudinal magnetization magnitude Mz\n\n\n\n\n\n","category":"method"},{"location":"api/#GrapeMR.update!-Tuple{ControlField, Tuple{Matrix{Float64}, Matrix{Float64}}, Float64}","page":"API","title":"GrapeMR.update!","text":"update(cf::ControlField, ∇xy::Tuple, ϵ::Float64)\n\nupdate\n\nArguments\n\ncf:  (::ControlField) - Control fields struct\n∇xy: (::Tuple) - Calculated gradients for x and y components\nϵ:   (::Float64) - Weigth of gradient\n\nOutputs\n\nControl Field - 1xN matrix\n\n\n\n\n\n","category":"method"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"../tutorial.jl\"","category":"page"},{"location":"generated/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"The goal is to show how to implement the GrapeMR.jl package","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"Define your physical system: Spins, relaxation values, inhomogeneities, etc.\nOptimization parameters: Scheduler parameters, max iterations, etc.\nGrape Parameters: Time steps, cost function and which fields to optimize.\nGenerate initial control field: Spline","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"using GrapeMR","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"Physical system: Initial magnetization state, relaxation values in seconds, label are the spins names, target: cost function dependent, B0 inhomonegenty in Herz. At the end, create the spin object with all spins","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"M0 = [0.0, 0.0, 1.0]\nT1 = [1.3, 0.73]\nT2 = [2.0, 0.04]\nlabel  = [\"T1=$(T1[1]*1e3)ms\", \"T1=$(T1[2]*1e3)ms\"]\ntarget = [\"min\", \"max\"]\nB0 = 30.0\noffset = collect(-B0/2:5:B0/2)\nΔB1 = [1.0]\nspins = Spin(M0, T1, T2, offset, ΔB1, target, label)","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"Optimization Parameters:","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"max_iter = get(ENV, \"DEV\", \"false\") == \"true\" ? 1 : 2000  # we set max_iter to 1 if we're in development mode to build the docs faster\nTc, poly_start, poly_degree = 0.836, 0.1, 1\nopt_params = OptimizationParams(poly_start, poly_degree, Int(ceil(max_iter)))","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"Grape Parameters","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"grape_params = GrapeParams(1500, GrapeMR.saturation_contrast_Mx, [true true false])","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"RF","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"N = 1500\nB1ref = 1.0\ncontrol_field = spline_RF(N, Tc, B1ref)","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"Run Optimization","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"params = Parameters(grape_params, opt_params)\ngrape_output = grape(params, control_field, spins);\nnothing #hide","category":"page"},{"location":"generated/tutorial/#Plots","page":"Tutorial","title":"Plots","text":"","category":"section"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"using GrapeMR, Plots; unicodeplots(); # change the backend so that plots go to stdout and can be rendered in CI/headless mode.\ndefault(show = false); #hide\ncontrol_fields = plot_control_fields(grape_output.control_field);\ndisplay(control_fields)","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"The Spin struct:","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"[(k, v) for (k, v) in zip(fieldnames(GrapeMR.Spin), fieldtypes(GrapeMR.Spin))]","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#GrapeMR.jl","page":"Introduction","title":"GrapeMR.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Grape Logo) Documentation for GrapeMR.jl","category":"page"},{"location":"#Magnetic-systems","page":"Introduction","title":"Magnetic systems","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Given a homogeneus magnetic field vecB_0 = B_0textbfz \nMagnetic moments align with vecB_0 resulting in a bulk magnetization M_0 along the z-axis.\nThe presence of vecB_0 gives raise (?) to a resonance condition specific for each atomic nuclei.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"omega_0 = -gamma B_0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where omega_0 [rads/s] is the Larmor frequency, gamma [rads/s/T]  the gyromagnetic ratio and B_0 [T] the homogenios magnetic field. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"An inhomogeneous magnetic field B_1(t), perpendicular to B_0, when irradiated in the resonance frequency, rotates the magnetization. The rotation angle is described as, ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"alpha = 2 pi gamma B_1 Delta t","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where Delta t is the duration of the B_1(t) field. Because the gyromagnetic ratio of the proton is O(MHz), so is the B_1(t), hence, radio frequency field. It can be rewritten as a combination of its x-y components, B_1(t) = B_1x + i B_1y. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Once B_1(t) is turned off, the system starts to relax back to equilibrium, generating a signal called FID (Free Induction Decay).\nThe relaxation parameters, T_1 and T_2, are individual to each molecule, therefore, generating different decays for different molecules excited by the same RF pulse.\nFrom the signal detected, one can calculate the magnetization values.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<!– ","category":"page"},{"location":"#Optimal-Control","page":"Introduction","title":"Optimal Control","text":"","category":"section"},{"location":"#Description-of-System-Dynamics","page":"Introduction","title":"Description of System Dynamics","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The dynamics of a system can be mathematically described by the following system of equations:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"begincases\n    dotvecx(t) = vecf(x(t)) \n    x(0) = x_0 (t  0)\nendcases","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Here, vecf represents all of the forces acting on the system. In a control dynamics, a function u(t), called the control function, is introduced to allow for manipulation of the system. The system dynamics can now be written as:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"begincases\n    dotvecx(t) = vecf(x(t) u(t)) \n    x(0) = x_0 (t  0) \nendcases","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The goal in this type of system is to find the \"best set\" of controls. To achieve this, a reward function C is introduced. If u^*(t) is the optimal control, then for all u(t), the reward function satisfies:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"C(u^*)  C(u)","category":"page"},{"location":"#Optimal-Control-in-NMR","page":"Introduction","title":"Optimal Control in NMR","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"In Nuclear Magnetic Resonance (NMR), a controled dynamics can be achieved by designing the RF pulses as the controls. Hence, the magnetization dynamics would be proportional to,","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"dotM(t) = f(M_0 T_1 T_2 B_1(t) M(t))","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"More specifically, the dynamics are governed by the Bloch Equations, which can be expressed as follows:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"beginbmatrix\n    dotM_x  dotM_y  dotM_z\nendbmatrix = \nbeginbmatrix\n    -1T_2  Delta B_0  -B1_y \n    -Delta B_0  -1T_2  B1_x \n    B1_y  -B1_x  1T_1\nendbmatrix\nbeginbmatrix\n    M_x  M_y  M_z\nendbmatrix + \nbeginbmatrix\n    0  0  M_0T_1\nendbmatrix","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where the dynamics of the magnetization is described by the vector vecM = (M_x M_y M_z). ","category":"page"},{"location":"#Cost-Function","page":"Introduction","title":"Cost Function","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Defining a cost function is essencial in this processes since it is based on it that the system will be optimized. In the case of contrast saturation, given two samples a and b, the goal is to supress one signal while maximizing the other. This can be achieved using the following cost function:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"C^(ab) = vecM^(b)(t_f) - (M_z^(a)(t_f))^2","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This cost function yields the best value of -1 when the signal of sample a is zero and the signal of sample b is maximum.","category":"page"},{"location":"#GRAPE-Algorithm","page":"Introduction","title":"GRAPE Algorithm","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The basic algorithm for optimization is Gradient Ascent, which can be described using the following steps:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Choose an initial control field (can be an arbitrary smart guess);\nCompute the cost function C(u);\nCompute the gradient fracdelta Cdelta u;\nUpdate the current control field using the formula: vecomega^(n + 1) = vecomega^(n) - gamma fracdelta Cdelta u;\nRepeat 2-4 until convergence.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"While this is the simplest way to apply the gradient ascent algorithm, a more precise approach involves using forward and backward propagation to update the control field. This approach will be discussed in the following section.  –>","category":"page"}]
}
