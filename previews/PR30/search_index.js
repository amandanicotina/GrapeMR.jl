var documenterSearchIndex = {"docs":
[{"location":"pages/api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"pages/api/","page":"API","title":"API","text":"Modules = [GrapeMR]\nOrder   = [:function, :type]","category":"page"},{"location":"pages/api/#GrapeMR.RF_pulse_analysis-Tuple{ControlField}","page":"API","title":"GrapeMR.RF_pulse_analysis","text":"RF_pulse_analysis(cf::ControlField; attenuation_ref = 0.0, B1_ref = 1.0, power_ref = 500.0)\n\nCalculate calibration analysis of shaped pulse\n\nArguments\n\ncf::ControlField: The control field object containing the RF waveform.\nattenuation_ref::Float64: Reference attenuation in dB (default is 0.0 dB).\nB1_ref::Float64: Reference RF field strength in Tesla (default is 1.0 T).\npower_ref::Float64: Reference RF power in Watts (default is 500.0 W).\n\nOutputs:\n\nA tuple of calculated values:\n\nmax_amp: Maximum RF amplitude in Hertz (Hz).\nmax_amp_tesla: Maximum RF amplitude in microtesla (µT).\nattenuation_B1: Attenuation in decibels (dB).\npower_max_B1: Maximum power in Watts (W).\npower_average: Average power in Watts (W).\npulse_energy: Pulse energy in Joules (J).\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.amplitudes_and_phases-Tuple{ControlField}","page":"API","title":"GrapeMR.amplitudes_and_phases","text":"amplitudes_and_phases(cf::ControlField)\n\nCalculates amplitudes and phases in Hz and radians\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.bSSFP_RF-Tuple{Int64, Int64, Real, Float64}","page":"API","title":"GrapeMR.bSSFP_RF","text":"bSSFP_RF(N::Int, nTR::Int, α::Real, TR::Float64)\n\nGenerates an RF pulse sequence for bSSFP with specified flip angle and repetition time.\n\nArguments\n\nN::Int: Number of points per repetition.\nnTR::Int: Number of TR periods (repetitions).\nα::Real: Flip angle in radians.\nTR::Float64: Repetition time in seconds.\n\nReturns\n\nA 1D array containing the bSSFP RF pulse sequence.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.backward_propagation!-Tuple{AbstractMatrix, ControlField, Isochromat}","page":"API","title":"GrapeMR.backward_propagation!","text":"backward_propagation!(χ::AbstractMatrix, cf::ControlField, iso::Isochromat)\n\nIn-place backward propagation for the adjoint state matrix, calculating gradients for the control fields.\n\nArguments\n\nχ::AbstractMatrix: Matrix to store the adjoint state (4xN).\ncf::ControlField: Struct containing control field parameters.\niso::Isochromat: Isochromat containing the magnetization data for backward propagation.\n\nReturns\n\nχ: Updated adjoint state matrix (4xN) after backward propagation.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.backward_propagation-Tuple{AbstractVector, ControlField, Isochromat}","page":"API","title":"GrapeMR.backward_propagation","text":"backward_propagation(cost_grad::AbstractVector, cf::ControlField, iso::Isochromat)\n\nPerforms backward propagation for the adjoint state matrix, calculating gradients for the control fields.\n\nArguments\n\ncost_grad::AbstractVector: Gradient of the cost function for the initial adjoint state.\ncf::ControlField: Struct containing control field parameters.\niso::Isochromat: Isochromat containing the magnetization data for backward propagation.\n\nReturns\n\nχ::Matrix{Float64}: Adjoint state matrix (4xN) after backward propagation.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.bandwidth_factor-Tuple{}","page":"API","title":"GrapeMR.bandwidth_factor","text":"bandwidth_factor(cf::ControlField)\n\nExcitation frequency range\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.bloch_matrix-NTuple{5, Float64}","page":"API","title":"GrapeMR.bloch_matrix","text":"bloch_matrix(B1x::Float64, B1y::Float64, Bz::Float64, Γ1::Float64, Γ2::Float64)\n\nCalculates the Bloch matrix for spin dynamics.\n\nArguments\n\nB1x::Float64: x-component of the B1 field.\nB1y::Float64: y-component of the B1 field.\nBz::Float64: z-component of the magnetic field.\nΓ1::Float64: Longitudinal relaxation rate.\nΓ2::Float64: Transverse relaxation rate.\n\nReturns\n\nA 4x4 Bloch matrix based on the given field components and relaxation rates.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.bohb_hyperopt-Tuple{Vector{<:Spins}, GrapeParams, LinRange, Int64}","page":"API","title":"GrapeMR.bohb_hyperopt","text":"bohb_hyperopt(spins::Vector{<:Spins}, \n              gp::GrapeParams, \n              Tc::LinRange, \n              max_iter::Int; \n              i::Int=5, \n              poly_start::Vector{Float64} = [5e-1, 1e-1, 1e-2], \n              poly_degree::Vector{Int} = [1, 2], \n              B1ref::Float64 = 1.0)\n\nPerforms hyperparameter optimization using Bayesian Optimization and Hyperband (BOHB).\n\nArguments\n\nspins::Vector{<:Spins}: Vector of spin systems for the optimization process.\ngp::GrapeParams: GRAPE algorithm parameters, including cost function and fields to optimize.\nTc::LinRange: Range for time control points for spline interpolation.\nmax_iter::Int: Maximum number of optimization iterations.\ni::Int=5: Number of optimization evaluations.\npoly_start::Vector{Float64}: Initial values for polynomial learning rate.\npoly_degree::Vector{Int}: Degrees for the polynomial learning rate.\nB1ref::Float64=1.0: Reference B1 field amplitude.\n\nReturns\n\nA BOHB optimization object with optimized hyperparameter configurations and costs.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.bruker_normalized_amplitudes_and_phases-Tuple{ControlField}","page":"API","title":"GrapeMR.bruker_normalized_amplitudes_and_phases","text":"bruker_normalized_amplitudes_and_phases(cf::ControlField)\n\nCalculates amplitudes and phases normalized to 100 and 180 deg for Bruker implementation on TopSpin. All negative phase values are added a 360deg phase\n\nArguments\n\ncf::ControlField: The control field object containing the RF waveform.\n\nOutputs:\n\nA tuple of normalized amplitudes and phases:\n\nnorm_amp: Maximum RF amplitude in Hertz (Hz).\nnorm_phase: Normalize phases in degrees. \n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.color_palette-Tuple{Union{Int64, AbstractArray}}","page":"API","title":"GrapeMR.color_palette","text":"color_palette(var::Union{AbstractArray, Int})\n\nGenerates a color palette using the rainbow color scheme for the specified array of indices or integer count.\n\nArguments\n\nvar::Union{AbstractArray, Int}: Array or integer specifying the number of colors required.\n\nReturns\n\nA ColorScheme object with colors matching the length or count of var.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.complex_signal-Tuple{ControlField}","page":"API","title":"GrapeMR.complex_signal","text":"complex_signal(cf::ControlField)\n\nCalculates complex RF signal in Hz\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.cost_offsets-Tuple{ControlField, Spin, Vector{Float64}, Function}","page":"API","title":"GrapeMR.cost_offsets","text":"cost_offsets(control_field::ControlField, spin_system::Spin, offsets::Vector{Float64})\n\nCalculates the cost values for a given control field (control_field) and spin system (spin_system) over a range of B0 inhomogeneities (offsets).\n\nArguments\n\ncontrol_field::ControlField: The control field object that contains the RF pulse sequence.\nspin_system::Spin: The spin system for which the cost function is to be calculated.\noffsets::Vector{Float64}: A vector of offset frequencies (in Hz) representing B0 inhomogeneities.\n\nOutputs\n\ncost_values::Vector{Float64}: A vector containing the cost values corresponding to each offset in B0_values.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.countour_cost-Tuple{Matrix{Float64}, Vector{Float64}, Vector{Float64}}","page":"API","title":"GrapeMR.countour_cost","text":"countour_cost(cost_matrix::Matrix{Float64})\n\nCreates a contour plot of the cost function values over the range of B0 and B1 inhomogeneities.\n\nArguments\n\ncost_matrix::Matrix{Float64}: A 2D matrix representing the cost values for combinations of B0 and B1 inhomogeneities.\n\nOutputs\n\nc::Plot: A contour plot of the cost function map.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.create_cost_matrix-Tuple{ControlField, Spin, Vector{Float64}, Vector{Float64}, Function}","page":"API","title":"GrapeMR.create_cost_matrix","text":"create_cost_matrix(control_field::ControlField, spin_system::Spin, offsets::Vector{Float64}, b1_inhomogeneities::Vector{Float64})\n\nGenerates a cost matrix representing the cost function values across a range of B0 and B1 inhomogeneities.\n\nArguments\n\ncontrol_field::ControlField: The control field object that contains the RF pulse sequence\nspin_system::Spin: The spin system for which the cost function is to be calculated.\noffsets::Vector{Float64}: A vector of offset frequencies (in Hz) representing B0 inhomogeneities.\nb1_inhomogeneities::Vector{Float64}: A vector representing B1 inhomogeneity percentages.\n\nOutputs\n\ncost_matrix::Matrix{Float64}: A 2D matrix where each element represents the cost value for a particular                                        combination of B0 and B1 values. The matrix is normalized by its maximum value.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.create_folder-Tuple{String}","page":"API","title":"GrapeMR.create_folder","text":"create_folder(path::String)\n\nCreates a folder at the specified path if it doesn't already exist.\n\nArguments\n\npath::String: The path where the folder will be created.\n\nOutput\n\nReturns the path to the created folder. If the folder already exists, it simply returns the path.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.create_spline-Tuple{AbstractArray, AbstractArray, AbstractArray}","page":"API","title":"GrapeMR.create_spline","text":"create_spline(spline_time::AbstractArray, control_time_vals::AbstractArray, B1_random_vals::AbstractArray)\n\nCreates a cubic spline interpolation for the control field based on the specified time and amplitude values.\n\nArguments\n\nspline_time::AbstractArray: Array of time points for the spline.\ncontrol_time_vals::AbstractArray: Array of control time points for evaluation.\nB1_random_vals::AbstractArray: Array of B1 amplitude values for spline generation.\n\nReturns\n\nArray of interpolated control field values at each control time.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.dynamics-Tuple{ControlField, Spins}","page":"API","title":"GrapeMR.dynamics","text":"dynamics(cf::ControlField, spin::Spins)\n\nCalculates and returns the Isochromat object representing the spin dynamics under a given control field.\n\nArguments\n\ncf::ControlField: Control field affecting the spin dynamics.\nspin::Spin: Spin object for which dynamics are computed.\n\nReturns\n\niso::Isochromat: Isochromat containing the calculated magnetization dynamics.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.export_bruker-Tuple{GrapeOutput}","page":"API","title":"GrapeMR.export_bruker","text":"export_bruker(go::GrapeOutput; folder_path = pwd())\n\nExports the GRAPE optimization results to a Bruker-compatible .exc file format for use in TopSpin software.\n\nArguments\n\ngo::GrapeOutput: The output struct from GRAPE optimization containing control field data.\nfolder_path::String=pwd(): The directory path where the .exc file will be saved. Defaults to the current working directory.\n\nFile Structure\n\nThe generated file includes metadata such as date, time, amplitude, and phase ranges.\nAmplitude and phase data points are formatted for compatibility with Bruker TopSpin.\n\nOutputs\n\nSaves a .exc file named based on the GRAPE output and current configuration in the specified folder.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.forward_propagation!-Tuple{AbstractMatrix, ControlField, Spins}","page":"API","title":"GrapeMR.forward_propagation!","text":"forward_propagation!(M::AbstractMatrix, cf::ControlField, s::Spins)\n\nIn-place version of forward propagation that updates the provided magnetization matrix.\n\nArguments\n\nM::AbstractMatrix: Matrix to store the forward-propagated magnetization (4xN).\ncf::ControlField: Struct containing control field parameters.\ns::Spins: Spin struct with initial magnetization and relaxation parameters.\n\nReturns\n\nM: Updated magnetization matrix (4xN) with forward propagation results.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.forward_propagation-Tuple{ControlField, Spins}","page":"API","title":"GrapeMR.forward_propagation","text":"forward_propagation(cf::ControlField, s::Spins)\n\nPerforms forward propagation for the magnetization vector under the influence of control fields.\n\nArguments\n\ncf::ControlField: Struct containing control field parameters.\ns::Spins: Spin struct with initial magnetization and relaxation parameters.\n\nReturns\n\nM::Matrix{Float64}: Magnetization matrix (4xN) at each time step.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.gaussian_RF-Tuple{Int64, Float64, Float64}","page":"API","title":"GrapeMR.gaussian_RF","text":"gaussian_RF(N::Int, t_c::Float64, B1ref::Float64)\n\nGenerates a Gaussian-shaped RF pulse.\n\nArguments\n\nN::Int: Number of time points.\nt_c::Float64: Duration of the pulse in seconds.\nB1ref::Float64: Reference amplitude for scaling the pulse.\n\nReturns\n\nA ControlField struct with Gaussian-distributed B1x and B1y components.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.get_resources_configurations_hband-Tuple{Int64, Float32}","page":"API","title":"GrapeMR.get_resources_configurations_hband","text":"get_resources_configurations_hband(η::Int, R::Float32)\n\nCalculates the resources and configurations for each stage of the Hyperband algorithm.\n\nArguments\n\nη::Int: Downsampling factor, typically used in Hyperband.\nR::Float32: Maximum resource budget (e.g., number of iterations).\n\nReturns\n\nPrints the calculated resources (n) and budgets (r) for each Hyperband stage.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.get_target_properties-Tuple{Any, Any}","page":"API","title":"GrapeMR.get_target_properties","text":"get_target_properties(s, colors)\n\nDetermines the color and label for a given spin target (\"max\", \"min\", or default).\n\nArguments\n\ns::Spin: A spin object with target and label properties.\ncolors::Vector: A vector of colors from the color palette.\n\nReturns\n\nA tuple (color, label) with the color and label for the given spin target.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.gradient-Tuple{Matrix{Float64}, Matrix{Float64}, AbstractMatrix{Int64}}","page":"API","title":"GrapeMR.gradient","text":"gradient(χ::Matrix{Float64}, M::Matrix{Float64}, H::Matrix)\n\nCalculates the gradient of the cost function with respect to the Hamiltonian for each time step.\n\nArguments\n\nχ::Matrix{Float64}: Adjoint state matrix.\nM::Matrix{Float64}: Forward propagation matrix.\nH::Matrix: Hamiltonian matrix.\n\nReturns\n\ngrad::Matrix{Float64}: Gradient of the cost function, as a 1xN matrix.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.grape-Tuple{Parameters, ControlField, Vector{<:Spins}}","page":"API","title":"GrapeMR.grape","text":"grape(p::Parameters, cf::ControlField, spins::Vector{<:Spins})\n\nExecutes the GRAPE algorithm to optimize control fields for spin dynamics in an NMR/MRI system.\n\nArguments\n\np::Parameters: Struct containing optimization parameters, including maximum iterations and cost function.\ncf::ControlField: Initial control field, typically as a spline function.\nspins::Vector{<:Spins}: Vector of spins included in the optimization process.\n\nReturns\n\ngrape_output::GrapeOutput: Struct containing optimization results, including optimized control fields, spin dynamics, and cost function values.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.hard_RF-Tuple{Any, Any, Any}","page":"API","title":"GrapeMR.hard_RF","text":"hard_RF(N::Int, t_c::Float64, B1ref::Float64)\n\nGenerates a hard RF pulse with constant amplitude in the x-axis and zero amplitude in the y-axis.\n\nArguments\n\nN::Int: Number of time points.\nt_c::Float64: Duration of the pulse in seconds.\nB1ref::Float64: Amplitude of the RF pulse.\n\nReturns\n\nA ControlField struct with constant B1x and zero B1y components.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.hband_hyperopt-Tuple{Vector{<:Spins}, GrapeParams, LinRange, Int64}","page":"API","title":"GrapeMR.hband_hyperopt","text":"hband_hyperopt(spins::Vector{<:Spins}, \n               gp::GrapeParams, \n               Tc::LinRange, \n               max_iter::Int; \n               B1ref::Float64 = 1.0)\n\nExecutes Hyperband optimization for selecting hyperparameters.\n\nArguments\n\nspins::Vector{<:Spins}: Vector of spin systems for the optimization process.\ngp::GrapeParams: GRAPE algorithm parameters, including cost function and fields to optimize.\nTc::LinRange: Range for time control points for spline interpolation.\nmax_iter::Int: Maximum number of optimization iterations.\nB1ref::Float64=1.0: Reference B1 field amplitude.\n\nReturns\n\nA Hyperband optimization object with configurations, costs, and history.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.initialize_plot-Tuple{String, String, String}","page":"API","title":"GrapeMR.initialize_plot","text":"initialize_plot(title, xlabel, ylabel; zlabel=nothing)\n\nCreates a plot object with common settings and title and axis labels.\n\nArguments\n\ntitle::String: Title of the plot.\nxlabel::String: Label for the x-axis.\nylabel::String: Label for the y-axis.\nzlabel::Union{String, Nothing}: Label for the z-axis (optional, only for 3D plots).\n\nReturns\n\np: A plot object with preconfigured labels and settings.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.integral_factor-Tuple{ControlField}","page":"API","title":"GrapeMR.integral_factor","text":"integral_factor(cf::ControlField)\n\nPower or energy of the RF pulse integrated over its duration\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.max_peak_amp-Tuple{Vector{ComplexF64}}","page":"API","title":"GrapeMR.max_peak_amp","text":"max_peak_amp(B1::Vector{ComplexF64})\n\nReturns the maximum RF amplitude in Hz\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.max_peak_amp_tesla-Tuple{Vector{ComplexF64}}","page":"API","title":"GrapeMR.max_peak_amp_tesla","text":"max_peak_amp_tesla(B1::Vector{ComplexF64})\n\nReturns the maximum RF amplitude in Tesla\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.plot_config-Tuple{}","page":"API","title":"GrapeMR.plot_config","text":"plot_config()\n\nSets up a default plot configuration for consistency in appearance across plots.\n\nReturns\n\np: A plot object with font sizes, frame style, and grid style preconfigured.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.plot_control_fields-Tuple{ControlField}","page":"API","title":"GrapeMR.plot_control_fields","text":"plot_control_fields(cf::ControlField; unit::String = \"Hz\")\n\nPlot the control fields of an RF pulse in different units.\n\nArguments\n\ncf::ControlField: The control field object containing the RF waveform data (B1x, B1y components).\nunit::String: The unit for the plot. Supported units are:\n\"Hz\": Plots B1x and B1y in Hertz.\n\"rad/s\": Converts the control fields to rads/sec and plots the amplitude and phase.\n\"Tesla\": Converts the control fields to Tesla using the gyromagnetic ratio for ¹H and plots in microtesla (µT).\n\nReturns\n\nA plot object displaying the control fields in the specified units with amplitude and phase information.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.plot_control_fields_phase_shift-Tuple{ControlField}","page":"API","title":"GrapeMR.plot_control_fields_phase_shift","text":"plot_control_fields_phase_shift(cf::ControlField; ψ::Float64 = π)\n\nPlot the control fields of an RF pulse after applying a phase shift.\n\nArguments\n\ncf::ControlField: The control field object containing the RF waveform data (B1x, B1y components).\nψ::Float64: The phase shift to apply to the control fields (default is π radians).\n\nReturns\n\nA plot object displaying the control fields with the specified phase shift.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.plot_cost_offset-Tuple{Vector{Float64}, Vector{Float64}}","page":"API","title":"GrapeMR.plot_cost_offset","text":"plot_cost_offset(cost_profile::Vector{Float64}, B0_values::Vector{Float64})\n\nCreates a plot of the cost values as a function of B0 offset frequencies.\n\nArguments\n\ncost_profile::Vector{Float64}: A vector containing the cost values to be plotted.\nB0_values::Vector{Float64}: A vector of offset frequencies (in Hz) corresponding to the cost values.\n\nOutputs\n\np::Plot: A plot object displaying the cost function offset profile.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.plot_cost_values-Tuple{Vector{Float64}, GrapeParams}","page":"API","title":"GrapeMR.plot_cost_values","text":"plot_cost_values(cost::Vector{Float64}, gp::GrapeParams)\n\nPlot the cost function convergence over iterations during the GRAPE optimization process.\n\nArguments\n\ncost::Vector{Float64}: A vector containing the cost values at each iteration.\ngp::GrapeParams: The parameters of the GRAPE optimization, including the cost function name.\n\nReturns\n\nA plot object displaying the convergence of the cost function over the iterations.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.plot_longitudinal_time-Tuple{Vector{Isochromat}, Float64}","page":"API","title":"GrapeMR.plot_longitudinal_time","text":"plot_longitudinal_time(isos::Vector{Isochromat}, t::Float64)\n\nPlots the longitudinal magnetization (Mz) as a function of time for a set of isochromats.\n\nArguments\n\nisos::Vector{Isochromat}: A vector of Isochromat objects containing magnetization and spin data.\nt::Float64: Total time duration for the plot.\n\nReturns\n\npLongTime: A plot object displaying Mz as a function of time for each isochromat.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.plot_magnetization_2D-Tuple{Vector{Isochromat}}","page":"API","title":"GrapeMR.plot_magnetization_2D","text":"plot_magnetization_2D(isos::Vector{Isochromat})\n\nPlots the 2D magnetization, showing transverse (Mxy) vs longitudinal (Mz) magnetization.\n\nArguments\n\nisos::Vector{Isochromat}: A vector of Isochromat objects containing magnetization and spin data.\n\nReturns\n\npMag2D: A plot object displaying the transverse (Mxy) vs longitudinal (Mz) magnetization.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.plot_magnetization_3D-Tuple{Vector{Isochromat}}","page":"API","title":"GrapeMR.plot_magnetization_3D","text":"plot_magnetization_3D(isos::Vector{Isochromat})\n\nPlots the 3D magnetization (Mx, My, Mz) for a set of isochromats.\n\nArguments\n\nisos::Vector{Isochromat}: A vector of Isochromat objects containing magnetization and spin data.\n\nReturns\n\npMag3D: A plot object displaying the 3D magnetization components (Mx, My, Mz) for each isochromat.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.plot_magnetization_control_field-Tuple{ControlField, Vector{Isochromat}}","page":"API","title":"GrapeMR.plot_magnetization_control_field","text":"plot_magnetization_control_field(cf::ControlField, isos::Vector{Isochromat})\n\nPlot the magnetization trajectory for a set of isochromats and the corresponding control field.\n\nArguments\n\ncf::ControlField: The control field object containing the RF waveform data (B1x, B1y components).\nisos::Vector{Isochromat}: A vector of isochromat objects representing different spin systems.\n\nReturns\n\nA plot object displaying:\nThe magnetization trajectory in the transverse plane.\nThe control field amplitude and phase over time.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.plot_magnetization_time-Tuple{Isochromat, Float64}","page":"API","title":"GrapeMR.plot_magnetization_time","text":"plot_magnetization_time(iso::Isochromat, t::Float64)\n\nPlots the time evolution of magnetization components (Mx, My, Mz) for a single isochromat.\n\nArguments\n\niso::Isochromat: An Isochromat object containing magnetization dynamics.\nt::Float64: Total time duration of the plot.\n\nReturns\n\npMagTime: A plot object displaying Mx, My, and Mz as functions of time.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.plot_transverse_magnetization-Tuple{Vector{Isochromat}}","page":"API","title":"GrapeMR.plot_transverse_magnetization","text":"plot_transverse_magnetization(isos::Vector{Isochromat})\n\nPlots the transverse magnetization (Mx and My) for a set of isochromats, with colors indicating different spin targets.\n\nArguments\n\nisos::Vector{Isochromat}: A vector of Isochromat objects containing magnetization and spin information.\n\nReturns\n\npTrans: A plot object displaying the transverse magnetization (Mx vs My) for each isochromat.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.plot_transverse_time-Tuple{Vector{Isochromat}, Float64}","page":"API","title":"GrapeMR.plot_transverse_time","text":"plot_transverse_time(isos::Vector{Isochromat}, t::Float64)\n\nPlots the transverse magnetization (Mxy) as a function of time for a set of isochromats.\n\nArguments\n\nisos::Vector{Isochromat}: A vector of Isochromat objects containing magnetization and spin data.\nt::Float64: Total time duration for the plot.\n\nReturns\n\npTransTime: A plot object displaying Mxy as a function of time for each isochromat.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.random_hyperopt-Tuple{Vector{<:Spins}, GrapeParams, LinRange, StepRange}","page":"API","title":"GrapeMR.random_hyperopt","text":"random_hyperopt(spins::Vector{<:Spins}, \n                gp::GrapeParams, \n                Tc::LinRange, \n                max_iter::StepRange; \n                i::Int = 50, \n                poly_start::Vector{Float64} = [5e-1, 1e-1, 1e-2], \n                poly_degree::Vector{Int} = [1, 2], \n                B1ref::Float64 = 1.0)\n\nPerforms random sampling for hyperparameter optimization.\n\nArguments\n\nspins::Vector{<:Spins}: A vector of spin systems for the optimization process.\ngp::GrapeParams: GRAPE algorithm parameters, including cost function and fields to optimize.\nTc::LinRange: Range for time control points for spline interpolation.\nmax_iter::StepRange: Range for maximum optimization iterations.\ni::Int=50: Number of random samples to evaluate.\npoly_start::Vector{Float64}: Initial values for polynomial learning rate.\npoly_degree::Vector{Int}: Degrees for the polynomial learning rate.\nB1ref::Float64=1.0: Reference B1 field amplitude.\n\nReturns\n\nA hyperparameter optimization object with randomly sampled configurations and their costs.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.run_cost_analysis-Tuple{ControlField, Spins, Float64, Int64, Function}","page":"API","title":"GrapeMR.run_cost_analysis","text":"run_cost_analysis(grape_output::GrapeOutput, offset::Float64, b1_inhomogeneity_percent::Int)\n\nRuns a complete cost analysis for the specified GrapeOutput object over a range of B0 and B1 inhomogeneities,  and generates plots to visualize the cost function.\n\nArguments\n\ncontrol_field::ControlField: The control field object that contains the RF pulse sequence.\nspin_system::Spin: The spin system for which the cost function is to be calculated.\noffset::Float64: The range of offset frequencies (in Hz) for the B0 inhomogeneities.\nb1_inhomogeneity_percent::Int: The percentage of B1 inhomogeneity to consider for the analysis.\n\nWorkflow\n\nGenerates a range of B0 values from -offset to offset.\nComputes cost values for the specified B0 and B1 inhomogeneities using cost_offsets and create_cost_matrix.\nPlots the cost function offset profile using plot_cost_offset.\nGenerates a heatmap of the cost matrix using heatmap_cost.\nCreates a contour plot of the cost matrix using countour_cost.\n\nExample\n\nruncostanalysis(grape_output, 50.0, 30)\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.run_grape_optimization-Tuple{String}","page":"API","title":"GrapeMR.run_grape_optimization","text":"run_grape_optimization(config_path::String)\n\nRuns the GRAPE optimization process based on a TOML configuration file. Initializes spins, sets up parameters, executes optimization, and optionally saves and plots the results.\n\nArguments\n\nconfig_path::String: Path to the TOML configuration file containing parameters for spins, optimization, and control fields.\n\nConfiguration File Structure\n\nThe TOML configuration file should include sections like:     - spins: Defines spin properties.     - grape_parameters: Parameters for the GRAPE optimization.     - optimization_parameters: Parameters for the hyperparameter optimization.     - control_field: Control field specifications.     - save_files: Settings for saving outputs.     - plot: Plot settings.\n\nReturns\n\nProduces and saves results depending on configuration settings, including optimized control fields, cost values, optional Bruker export, and plots.\n\nExample\n\n```julia rungrapeoptimization(\"path/to/config.toml\")\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.save_grape_data-Tuple{GrapeOutput}","page":"API","title":"GrapeMR.save_grape_data","text":"save_output_data(go::GrapeMR.GrapeOutput; folder_path = pwd())\n\nSave data related to GRAPE optimization into a folder organized by date.\n\nArguments\n\ngo::GrapeMR.GrapeOutput: The output from a GRAPE optimization process.\nfolder_path::String = pwd(): The folder path where data will be saved. Defaults to the current working directory.\n\nOutput\n\nReturns the full path to the folder where the data was saved.\n\nSaved Files\n\ngrape_output.jld2: Contains the entire GrapeOutput struct in JLD2 format.\ndict_cost_values.csv: CSV file containing the cost values from the optimization process.\ndict_control_field.csv: CSV file containing control field values (B1x, B1y, Bz, and RF time).\ndict_iso_spins.csv: CSV file containing isochromat spin parameters.\n\nIf no path is provided, it saves the files inside the folder where the package was installed folder name format : yyyy-mm-dd\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.save_hyperopt_data-Tuple{Any}","page":"API","title":"GrapeMR.save_hyperopt_data","text":"save_output_data(bohb::GrapeMR.GrapeOutput; folder_path = pwd())\n\nSave data related to BOHB optimization into a folder organized by date.\n\nArguments\n\nbohb::GrapeMR.GrapeOutput: The output from a BOHB optimization process.\nfolder_path::String = pwd(): The folder path where data will be saved. Defaults to the current working directory.\n\nOutput\n\nReturns the full path to the folder where the data was saved.\n\nSaved Files\n\nbohb.jld2: Contains BOHB result in JLD2 format.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.sinc_RF-Tuple{Int64, Float64, Float64}","page":"API","title":"GrapeMR.sinc_RF","text":"sinc_RF(N::Int, t_c::Float64, B1ref::Float64; α=π/2)\n\nGenerates a sinc RF pulse with a specified flip angle. Bandwidth hardcoded to 100 Hz. B1x and B1y have a π/2 phase difference\n\nArguments\n\nN::Int: Number of time points.\nt_c::Float64: Duration of the pulse in seconds.\nB1ref::Float64: Reference amplitude for scaling the pulse.\nα::Float64=π/2: Flip angle in radians.\n\nReturns\n\nA ControlField struct with B1x, B1y, and Bz components generated as sinc functions.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.spline_RF-Tuple{Any, Any, Any}","page":"API","title":"GrapeMR.spline_RF","text":"spline_RF(N::Int, t_c::Float64, B1ref::Float64)\n\nGenerates a cubic spline-based RF pulse.\n\nArguments\n\nN::Int: Number of time points.\nt_c::Float64: Duration of the pulse in seconds.\nB1ref::Float64: Reference amplitude for scaling the pulse.\n\nReturns\n\nA ControlField struct with B1x, B1y, and Bz components generated using spline interpolation.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.steady_state-Tuple{SteadyState}","page":"API","title":"GrapeMR.steady_state","text":"steady_state(s::GrapeMR.SteadyState)\n\nCalculates the steady-state signal of a bSSFP sequence for a given set of parameters. The function calculates the magnetization evolution  using repeated RF excitations and free precession steps until the steady state is reached.\n\nArguments\n\ns::GrapeMR.SteadyState: A struct containing TR (Repetition Time), TE (Echo Time), T1 (Spin-lattice relaxation time),                            T2 (Spin-spin relaxation time), α (Flip angle in radians), Δϕ (Phase cycling increment),                            M_init (Initial magnetization vector), and B0inho (B0 inhomogeneity).\n\nOutputs\n\nsignal::Vector{ComplexF64}: The complex steady-state signal of the spin system.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.steady_state_geometric-Tuple{SteadyState}","page":"API","title":"GrapeMR.steady_state_geometric","text":"steady_state_geometric(s::GrapeMR.SteadyState)\n\nCalculates the transverse steady-state magnetization using a geometric solution for a bSSFP sequence. Uses a geometric approach to  derive the transverse component of the steady-state magnetization.\n\nArguments\n\ns::GrapeMR.SteadyState: Struct containing the sequence parameters and spin system properties.\n\nOutputs\n\nMxy::Vector{Float64}: The steady-state transverse magnetization magnitude Mxy\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.steady_state_geometric_Mz-Tuple{SteadyState}","page":"API","title":"GrapeMR.steady_state_geometric_Mz","text":"steady_state_geometric_Mz(s::GrapeMR.SteadyState)\n\nCalculates the longitudinal steady-state magnetization using a geometric solution for a bSSFP sequence. Uses a geometric approach to  derive the longitudinal component of the steady-state magnetization.\n\nArguments\n\ns::GrapeMR.SteadyState: Struct containing the sequence parameters and spin system properties.\n\nOutputs\n\nMz::Vector{Float64}: The steady-state longitudinal magnetization magnitude Mz\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.update!-Tuple{ControlField, Tuple{Matrix{Float64}, Matrix{Float64}}, Float64}","page":"API","title":"GrapeMR.update!","text":"update!(cf::ControlField, ∇xy::Tuple, ϵ::Float64)\n\nUpdates the control fields based on the calculated gradient and a learning rate.\n\nArguments\n\ncf::ControlField: Control field struct to be updated.\n∇xy::Tuple{Matrix{Float64}, Matrix{Float64}}: Gradients for the x and y components of the field.\nϵ::Float64: Learning rate for gradient descent.\n\nReturns\n\n(u1x, u1y): Updated x and y control fields.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.ControlField","page":"API","title":"GrapeMR.ControlField","text":"ControlField{T, M1, Mz}\n\nRepresents the RF control field parameters for an NMR/MRI sequence.\n\nFields\n\nB1x::M1: Matrix for the x-component of the RF field.\nB1y::M1: Matrix for the y-component of the RF field.\nB1_ref::T: Reference amplitude of the RF field.\nBz::Mz: Matrix for the z-component of the magnetic field.\nt_control::T: Total control time for the sequence.\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#GrapeMR.GrapeOutput","page":"API","title":"GrapeMR.GrapeOutput","text":"GrapeOutput{T, M1, Mz, F}\n\nStores the output of GRAPE optimization.\n\nFields\n\nisochromats::Vector{Isochromat}: Vector of isochromats containing the spin dynamics.\ncontrol_field::ControlField{T, M1, Mz}: Optimized control field after GRAPE optimization.\ncost_values::Vector{Float64}: Sequence of cost function values at each iteration.\nparams::Parameters{F}: Struct containing GRAPE parameters and optimization parameters.\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#GrapeMR.GrapeParams","page":"API","title":"GrapeMR.GrapeParams","text":"GrapeParams{F}\n\nEncapsulates key parameters for the GRAPE optimization process.\n\nFields\n\nN::Int64: Number of time steps in the control sequence.\ncost_function::F: Function used to compute the optimization cost.\nfields_opt::Dict{String, Bool}: Dictionary indicating which fields to optimize (e.g., B1x, B1y).\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#GrapeMR.Isochromat","page":"API","title":"GrapeMR.Isochromat","text":"Isochromat{S}\n\nRepresents an isochromat, combining magnetization data with a specific spin configuration.\n\nFields\n\nmagnetization::Magnetization: Magnetization data associated with a collection or single isochromat.\nspin::S: Spin configuration for a collection or single isochromat.\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#GrapeMR.Magnetization","page":"API","title":"GrapeMR.Magnetization","text":"Magnetization{T, M}\n\nRepresents the magnetization dynamics of a spin system.\n\nFields\n\ndynamics::M: Time-evolution data for magnetization, either as a 4xN matrix.\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#GrapeMR.OptimizationParams","page":"API","title":"GrapeMR.OptimizationParams","text":"OptimizationParams\n\nDefines parameters for polynomial-based decay for ϵ in the GRAPE algorithm.\n\nFields\n\npoly_start::Float64: Initial polynomial coefficient.\npoly_degree::Int: Degree of the polynomial.\nmax_iter::Int: Maximum number of optimization iterations.\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#GrapeMR.Parameters","page":"API","title":"GrapeMR.Parameters","text":"Parameters{F}\n\nCombines GRAPE and optimization parameters for the full optimization process.\n\nFields\n\ngrape_params::GrapeParams{F}: GRAPE-specific optimization parameters.\nopt_params::OptimizationParams: General optimization parameters.\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#GrapeMR.Spin","page":"API","title":"GrapeMR.Spin","text":"Spin <: Spins\n\nGets relaxation parameters and inhomogeneity effects of the spin system.\n\nFields\n\nM_init::Vector{Float64}: Initial magnetization vector.\nT1::Float64: Longitudinal relaxation time.\nT2::Float64: Transverse relaxation time.\nB0inho::Float64: B0 inhomogeneity.\nB1inho::Float64: B1 inhomogeneity.\ntarget::String: Target magnetization state.\nlabel::String: Label for identifying the spin.\nNspins::Float64: Number of spins in this configuration.\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#GrapeMR.Spin-NTuple{7, Any}","page":"API","title":"GrapeMR.Spin","text":"Spin(M_ini, T1, T2, B0, B1, targets, labels)\n\nConstructs a collection of Spin instances with specified parameters.\n\nArguments\n\nM_ini::Vector{Float64}: Initial magnetization vector.\nT1::Vector{Float64}: Longitudinal relaxation times.\nT2::Vector{Float64}: Transverse relaxation times.\nB0::Vector{Float64}: Array of B0 inhomogeneity values.\nB1::Vector{Float64}: Array of B1 inhomogeneity values.\ntargets::Vector{String}: Target states for each spin configuration.\nlabels::Vector{String}: Labels for each spin configuration.\n\nReturns\n\nA vector of Spin instances covering all combinations of the provided parameters.\n\n\n\n\n\n","category":"method"},{"location":"pages/api/#GrapeMR.Spins","page":"API","title":"GrapeMR.Spins","text":"Spins\n\nAbstract type representing a generic spin system in NMR/MRI.\n\n\n\n\n\n","category":"type"},{"location":"pages/developing/#Developing","page":"Developing","title":"Developing","text":"","category":"section"},{"location":"pages/developing/","page":"Developing","title":"Developing","text":"In case you are interested in locally developing on GrapeMR, please follow the steps below. Consider opening an issue if you run into any problems or if you have any suggestions for improvements. In any case, please open an issue to discuss implementation ideas before starting to code or opening a pull request (PR) directly.","category":"page"},{"location":"pages/developing/#Getting-Started","page":"Developing","title":"Getting Started","text":"","category":"section"},{"location":"pages/developing/","page":"Developing","title":"Developing","text":"julia\njulia>] activate .\n(GrapeMR) pkg> instantiate\njulia>using GrapeMR","category":"page"},{"location":"pages/developing/#Documentation","page":"Developing","title":"Documentation","text":"","category":"section"},{"location":"pages/developing/","page":"Developing","title":"Developing","text":"julia -e 'using Pkg; Pkg.add(\"LiveServer\")'\njulia --project=docs -e 'using Pkg; Pkg.instantiate()'\njulia --project=docs -e 'using GrapeMR, LiveServer; ENV[\"DEV\"]=true; servedocs(skip_dirs=[\"docs/src/generated\"])'","category":"page"},{"location":"pages/developing/#Testing","page":"Developing","title":"Testing","text":"","category":"section"},{"location":"pages/developing/","page":"Developing","title":"Developing","text":"To run the tests, run the command below in your shell:","category":"page"},{"location":"pages/developing/","page":"Developing","title":"Developing","text":"julia --project=. -e 'using Pkg; Pkg.test(\"GrapeMR\"; coverage=true)'","category":"page"},{"location":"pages/developing/#Test-Coverage","page":"Developing","title":"Test Coverage","text":"","category":"section"},{"location":"pages/developing/","page":"Developing","title":"Developing","text":"In your global julia installation, ensure you have TestTools installed.","category":"page"},{"location":"pages/developing/","page":"Developing","title":"Developing","text":"using Pkg\nPkg.add(\"TestTools\")\nusing TestTools; TestTools.install()","category":"page"},{"location":"pages/developing/","page":"Developing","title":"Developing","text":"then add export PATH=\"$PATH:/Users/daviddodel/.julia/bin\" to your ~/.zshrc or equivalent shell configuration file.","category":"page"},{"location":"pages/developing/","page":"Developing","title":"Developing","text":"Note: You might need to restart the julia language server and VSCode to pick up the changes in the shell environment.","category":"page"},{"location":"pages/developing/#Local-Coverage-Report","page":"Developing","title":"Local Coverage Report","text":"","category":"section"},{"location":"pages/developing/","page":"Developing","title":"Developing","text":"using Pkg; Pkg.test(\"GrapeMR\"; coverage=true)\n# ';' is not a typo and will get you a shell within the current julia session\n;jlcoverage\n# Optional: Clean up all .cov files\nusing Coverage; Coverage.clean_folder(\".\");","category":"page"},{"location":"pages/developing/#VSCode","page":"Developing","title":"VSCode","text":"","category":"section"},{"location":"pages/developing/","page":"Developing","title":"Developing","text":"You might want to consider installing the Coverage Gutters extension to enable visual cues inside the code editor.","category":"page"},{"location":"pages/developing/","page":"Developing","title":"Developing","text":"To this end, you'll need to generate an lcov.info in your root directory:","category":"page"},{"location":"pages/developing/","page":"Developing","title":"Developing","text":"using Pkg; Pkg.test(\"GrapeMR\"; coverage=true)\nusing Coverage; LCOV.writefile(\"lcov.info\", process_folder())","category":"page"},{"location":"pages/developing/","page":"Developing","title":"Developing","text":"Go to the Command Palette: Coverage Gutters: Watch","category":"page"},{"location":"pages/theory/#Magnetic-systems","page":"Theoretical Background","title":"Magnetic systems","text":"","category":"section"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"In a homogeneous magnetic field vecB_0 = B_0mathbfz, magnetic moments align with vecB_0, resulting in a bulk magnetization M_0 along the z-axis. The presence of vecB_0 induces a resonance condition:","category":"page"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"omega_0 = -gamma B_0","category":"page"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"where omega_0 [rad/s] is the Larmor frequency, gamma [rad/s/T] is the gyromagnetic ratio, and B_0 [T] is the homogeneous magnetic field. When an oscillating magnetic field B_1(t), perpendicular to B_0, is applied at the resonance frequency, it rotates the magnetization. The rotation angle is given by:","category":"page"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"alpha = 2 pi gamma B_1 Delta t","category":"page"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"where Delta t is the duration of the B_1(t) field. Since the gyromagnetic ratio for the proton is on the order of MHz, the B_1(t) field operates at radio frequencies. This field can be represented as a combination of its x and y components: ","category":"page"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"B_1(t) = B_1x + i B_1y","category":"page"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Once B_1(t) is turned off, the system relaxes to equilibrium, generating a signal known as Free Induction Decay (FID). The relaxation parameters, T_1 and T_2, are unique to each molecule, resulting in distinct decay patterns for different molecules under the same RF pulse.","category":"page"},{"location":"pages/theory/#Optimal-Control","page":"Theoretical Background","title":"Optimal Control","text":"","category":"section"},{"location":"pages/theory/#Dynamics-*vs*-Controlled-Dynamics","page":"Theoretical Background","title":"Dynamics vs Controlled Dynamics","text":"","category":"section"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The following set of equations mathematically represent the dynamics of a system:","category":"page"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"begincases\n    dotvecx(t) = vecf(x(t)) \n x(0) = x_0 (t  0)\nendcases","category":"page"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Here, vecf represents all forces acting on the system. In a controlled system, a function u(t), known as the control function, is introduced to allow for dynamics manipulation. The system dynamics now become:","category":"page"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"begincases\n    dotvecx(t) = vecf(x(t) u(t)) \n x(0) = x_0 (t  0) \nendcases","category":"page"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Such a system aims to find the optimal set of controls. To achieve this, a reward function C is defined. If u^*(t) is the optimal control, then for any other control u(t), the reward function satisfies:","category":"page"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"C(u^*)  C(u)","category":"page"},{"location":"pages/theory/#Optimal-Control-in-NMR","page":"Theoretical Background","title":"Optimal Control in NMR","text":"","category":"section"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"In Nuclear Magnetic Resonance (NMR), controlled dynamics are achieved using RF pulses as control inputs. The magnetization dynamics are governed by the Bloch Equations, expressed as follows:","category":"page"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    fracddt beginpmatrix 1  M_x  M_y  M_z endpmatrix = \n        beginpmatrix\n            1  0  0  0 \n            0  -1T_2  Delta B_0  -mathbfu_y (t) \n            0  -Delta B_0  -1T_2  mathbfu_x (t) \n            1T_1  mathbfu_y (t)  -mathbfu_x (t)  -1T_1\n        endpmatrix\n        beginpmatrix 1  M_x  M_y  M_z endpmatrix","category":"page"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"where the magnetization vector vecM = (M_x M_y M_z) describes the system's state.","category":"page"},{"location":"pages/theory/#Cost-Function","page":"Theoretical Background","title":"Cost Function","text":"","category":"section"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Defining a cost function is crucial for the optimization. For contrast saturation, given two samples a and b, the goal is to suppress one signal while maximizing the other. This objective can be achieved with the following cost function:","category":"page"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"C^(ab) = vecM^(b)(t_f) - (M_z^(a)(t_f))^2","category":"page"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"This cost function achieves an optimal value of -1 when the signal from sample a is zero and the signal from sample b is maximized to 1.","category":"page"},{"location":"pages/theory/#GRAPE-Algorithm","page":"Theoretical Background","title":"GRAPE Algorithm","text":"","category":"section"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The algorithm step-by-step proceeds as follows:","category":"page"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Choose an initial control field mathbfu(t_0) (could be a smart guess or arbitrary).\nCalculate forward propagation of the magnetization vector mathbfM(t_0) rightarrow mathbfM(t_n).\nCalculate cost function value C(mathbfM(t_n)).\nCalculate backward propagation of the adjoint state boldsymbolchi(t_f) rightarrow boldsymbolchi(t_n).\nUpdate each of the current control fields as follows: mathbfu^n+1_i = mathbfu^n_i - epsilon fracpartial Cpartial mathbfu^n_i, for epsilon geq 0 and i = x y.\nRepeat 2-5 until convergence.","category":"page"},{"location":"pages/theory/#Forward-Propagation","page":"Theoretical Background","title":"Forward Propagation","text":"","category":"section"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"During forward propagation, the system's state evolves under the influence of the current control field. The Bloch Equations are solved for each time step. This step yields the system state at the final time t_f, which is then used to evaluate the cost function C.","category":"page"},{"location":"pages/theory/#Backward-Propagation","page":"Theoretical Background","title":"Backward Propagation","text":"","category":"section"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"After the cost function is computed, its gradient is calculated and used as the initial state, known as the adjoint state. This state is then propagated \"backward\" in time.","category":"page"},{"location":"pages/theory/#Gradient-Update","page":"Theoretical Background","title":"Gradient Update","text":"","category":"section"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The control field is updated using the results computed from the backward and forward propagation, according to the rule:","category":"page"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    fracpartial Cpartial mathbfu^n = chi_n+1^intercal I mathbfM_n Delta t ","category":"page"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Where I = I_x I_y is the matrix representation for each component of the control field. The update process repeats until the cost function reaches a minimum or predefined number of iterations.","category":"page"},{"location":"pages/theory/#Step-size","page":"Theoretical Background","title":"Step size","text":"","category":"section"},{"location":"pages/theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The step size epsilon controls how much the control field is adjusted in each iteration. A larger epsilon can speed up convergence but risks overshooting the optimal solution. A smaller epsilon results in slower convergence. Adaptive step size approaches adjust epsilon dynamically, effectively balancing speed and accuracy. These values are typically selected through initial testing or automatic search.","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"../tutorial.jl\"","category":"page"},{"location":"generated/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial demonstrates how to implement the GrapeMR.jl package by scripting a setup and directly calling its functions.","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"Define your physical system: Spins, relaxation values, inhomogeneities, etc.\nOptimization parameters: Scheduler parameters and maximum iterations.\nGrape Parameters: Time steps, cost function and which fields to optimize.\nGenerate initial control field: Cubic spline is used by default.","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"using GrapeMR","category":"page"},{"location":"generated/tutorial/#Saturation-contrast-without-inhomogeneities","page":"Tutorial","title":"Saturation contrast without inhomogeneities","text":"","category":"section"},{"location":"generated/tutorial/#Physical-system","page":"Tutorial","title":"Physical system","text":"","category":"section"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"Define the initial magnetization state, relaxation times (in seconds), and spin labels. Specify target according to the desired outcome (cost function-dependent) and offset for B_0 inhomogeneities in Hertz. Finally, create a Spin object with all spins. Each unique inhomogeneity combination is treated as a separate spin.","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"M0 = [0.0, 0.0, 1.0]\nT1 = [0.6, 0.1]\nT2 = [0.3, 0.05]\nΔB1 = [1.0]\nB0 = 0.0\noffset = collect(-B0:1:B0)\nlabel  = [\"s1\", \"s2\"]\ntarget = [\"min\", \"max\"]\nspins = Spin(M0, T1, T2, offset, ΔB1, target, label)","category":"page"},{"location":"generated/tutorial/#Parameters","page":"Tutorial","title":"Parameters","text":"","category":"section"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"Optimization Parameters","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"max_iter = get(ENV, \"DEV\", \"false\") == \"true\" ? 1 : 2000  # we set max_iter to 1 if we're in development mode to build the docs faster\npoly_start = 0.5\npoly_degree = 2\nopt_params = OptimizationParams(poly_start, poly_degree, max_iter)","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"Grape Parameters","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"N = 2000\ncost = GrapeMR.saturation_contrast\nfields2opt = Dict(\"B1x\" => true, \"B1y\" => true, \"Bz\" => false)\ngrape_params = GrapeParams(N, cost, fields2opt)","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"Parameter struct","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"params = Parameters(grape_params, opt_params)","category":"page"},{"location":"generated/tutorial/#Initial-control-field","page":"Tutorial","title":"Initial control field","text":"","category":"section"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"Generate an initial control field using the spline function. Set the control time control_time and reference amplitude B1ref.","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"B1ref = 1.0\ncontrol_time = 0.5\ncontrol_field = spline_RF(N, control_time, B1ref)","category":"page"},{"location":"generated/tutorial/#Run-Optimization","page":"Tutorial","title":"Run Optimization","text":"","category":"section"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"Run the optimization with the contructed Spins, configured Parameters and ControlField.","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"grape_output = grape(params, control_field, spins);\nnothing #hide","category":"page"},{"location":"generated/tutorial/#Plot","page":"Tutorial","title":"Plot","text":"","category":"section"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"using GrapeMR, Plots; unicodeplots(); # change the backend so that plots go to stdout and can be rendered in CI/headless mode.\ndefault(show = false); #hide\ncontrol_fields = plot_control_fields(grape_output.control_field);\ndisplay(control_fields)","category":"page"},{"location":"generated/tutorial/#Magnetization-saturation-with-B_0-inhomogeneity","page":"Tutorial","title":"Magnetization saturation with B_0 inhomogeneity","text":"","category":"section"},{"location":"generated/tutorial/#Physical-system-2","page":"Tutorial","title":"Physical system","text":"","category":"section"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"Optimizing pulses robust against field inhomogeneities. Here B_0 is the field inhomogeneity in Hertz and ΔB1 corresponds to the RF field inhomogeneity in percentage.","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"M0 = [0.0, 0.0, 1.0]\nT1 = [0.6]\nT2 = [0.3]\nΔB1 = [1.0]\nB0 = 15.0\nlabel  = [\"s1\"]\ntarget = [\"saturation\"]\noffset = -B0:1:B0\nspins = Spin(M0, T1, T2, offset, ΔB1, target, label)","category":"page"},{"location":"generated/tutorial/#Parameters-2","page":"Tutorial","title":"Parameters","text":"","category":"section"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"Optimization parameters","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"max_iter = get(ENV, \"DEV\", \"false\") == \"true\" ? 1 : 2000  # we set max_iter to 1 if we're in development mode to build the docs faster\npoly_start = 0.5\npoly_degree = 2\nopt_params = OptimizationParams(poly_start, poly_degree, max_iter)","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"Grape parameters","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"N = 2000\ncost = GrapeMR.euclidean_norm\nfields2opt = Dict(\"B1x\" => true, \"B1y\" => true, \"Bz\" => false)\ngrape_params = GrapeParams(N, cost, fields2opt)","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"Parameter struct","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"params = Parameters(grape_params, opt_params)","category":"page"},{"location":"generated/tutorial/#Initial-control-fields","page":"Tutorial","title":"Initial control fields","text":"","category":"section"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"B1ref = 5.0\ncontrol_time = 0.5\ncontrol_field = spline_RF(N, control_time, B1ref)","category":"page"},{"location":"generated/tutorial/#Run-optimization","page":"Tutorial","title":"Run optimization","text":"","category":"section"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"grape_output = grape(params, control_field, spins);\nnothing #hide","category":"page"},{"location":"generated/tutorial/#Plots","page":"Tutorial","title":"Plots","text":"","category":"section"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"using GrapeMR, Plots; unicodeplots(); # change the backend so that plots go to stdout and can be rendered in CI/headless mode.\ndefault(show = false); #hide\ncontrol_fields = plot_control_fields(grape_output.control_field);\ndisplay(control_fields)","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"generated/tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Grape Logo)","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GrapeMR.jl is a Julia package designed for optimizing radio-frequency (RF) pulses in NMR/MRI applications using the GRAPE (Gradient Ascent Pulse Engineering) algorithm. It enables the optimization of magnetic systems and supports various cost functions. It also comes with the option of hyperparameter search to handle more complex optimization problems. GrapeMR.jl can be applied in MRI for pre-acquisition pulse preparation, signal enhancement, and metabolomics for signal filtering.","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"#Installing-GrapeMR","page":"Home","title":"Installing GrapeMR","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use GrapeMR.jl, you’ll first need to install Julia, which can be downloaded from (here)[https://julialang.org/downloads/]. Once Julia is installed, open the Julia REPL and add GrapeMR as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\n(@v.1.11) pkg> add GrapeMR","category":"page"},{"location":"#Implementation-example","page":"Home","title":"Implementation example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A straightforward implementation involves creating a TOML file to define the system’s initial state, inhomogeneities, and relaxation values. The user will specify a cost function, the control field duration, and a path to save the output. A folder will be created in the GrapeMR installation directory if no path is provided. The package includes a default configuration file that you can modify or replace with your own.","category":"page"},{"location":"#Sample-TOML-file","page":"Home","title":"Sample TOML file","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"title = \"GrapeMR Configuration\"\nplot = true\n\n[spins]\nM0         = [0.0, 0.0, 1.0]\ndelta_B1   = [1.0]\noffset     = 0.0\nintrinsics = [\n    {T1 = 0.6, T2 = 0.3, label = \"s1\", target = \"Center of Bloch's Ball\"},\n]\n\n[grape_parameters]\ntime_steps      = 2000\ncost_function   = \"euclidean_norm\"\nfields2optimize = {\"B1x\" = true, \"B1y\" = true, \"Bz\" = false}\n\n\n[optimization_parameters]\nhyper_opt    = false\npoly_start   = 0.1\npoly_degree  = 1\nmax_iter     = 5000\n\n[control_field]\ncontrol_time = 0.5\nB1ref = 1.0\n\n[save_files]\nenabled = true\nexport_bruker = true\nfolder_path = \"/tmp/\"\nbruker_folder_path = \"/tmp/\"","category":"page"},{"location":"#Run-Configuration","page":"Home","title":"Run Configuration","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Run the configuration file with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using GrapeMR\njulia> run_grape_optimization(\"src/default_config.toml\")","category":"page"},{"location":"#Results","page":"Home","title":"Results","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After running the optimization, a grape_output.jld2 file is generated along with a plot of the optimized control field:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: cf_mag)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The RF pulse analysis is displayed after the optimization:","category":"page"},{"location":"","page":"Home","title":"Home","text":" Final cost value = 0.0052 \n\n---------- RF Analysis ---------- \n\nPulse Peak Amplitude = 2.5804 [Hz]\nPulse Peak Amplitude = 0.0606 [μT]\nAttenuation corresponding to maximum amplitude: 56.0692 [dB]\nMaximum power = 0.7862 [W]\nAverage power = 0.244 [W]\nPulse energy = 0.122 [J]","category":"page"},{"location":"pages/references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"pages/references/","page":"References","title":"References","text":"","category":"page"}]
}
